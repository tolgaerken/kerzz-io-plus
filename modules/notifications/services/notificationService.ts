import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Device from 'expo-device';
import { Alert, Platform } from 'react-native';
import { isFirebaseInitialized } from '../../../config/firebase';
import {
    FCMToken,
    NotificationPermission,
    NotificationSettings
} from '../types';

// Platform-specific imports
let notificationFunctions: any = {};

// Platform-specific Firebase functions will be loaded dynamically
const loadFirebaseFunctions = async () => {
  if (Platform.OS === 'web') {
    // Web i√ßin Firebase Web SDK
    try {
      const firebaseMessaging = await import('firebase/messaging');
      notificationFunctions = {
        getMessaging: firebaseMessaging.getMessaging,
        getToken: firebaseMessaging.getToken,
        onMessage: firebaseMessaging.onMessage,
        isSupported: firebaseMessaging.isSupported
      };
    } catch (error) {
      console.warn('‚ö†Ô∏è Firebase Web Messaging y√ºklenemedi:', error);
    }
  } else {
    // React Native i√ßin Firebase
    try {
      const firebaseMessaging = await import('@react-native-firebase/messaging');
      notificationFunctions = {
        AuthorizationStatus: firebaseMessaging.AuthorizationStatus,
        deleteToken: firebaseMessaging.deleteToken,
        getInitialNotification: firebaseMessaging.getInitialNotification,
        getMessaging: firebaseMessaging.getMessaging,
        getToken: firebaseMessaging.getToken,
        onMessage: firebaseMessaging.onMessage,
        onTokenRefresh: firebaseMessaging.onTokenRefresh,
        requestPermission: firebaseMessaging.requestPermission,
        setBackgroundMessageHandler: firebaseMessaging.setBackgroundMessageHandler,
        subscribeToTopic: firebaseMessaging.subscribeToTopic,
        unsubscribeFromTopic: firebaseMessaging.unsubscribeFromTopic
      };
    } catch (error) {
      console.warn('‚ö†Ô∏è React Native Firebase Messaging y√ºklenemedi:', error);
    }
  }
};

// Initialize functions
loadFirebaseFunctions();

class NotificationService {
  private static instance: NotificationService;
  private currentToken: string | null = null;
  private messageListener: (() => void) | null = null;
  private tokenRefreshListener: (() => void) | null = null;
  private backgroundMessageHandler: (() => void) | null = null;
  private messaging: any = null;

  // API Configuration
  private readonly smartyUrl = 'https://smarty.kerzz.com:4004';
  private readonly apiKey = '1453';
  private readonly adminEmail = 'tolga@kerzz.com';
  private readonly adminPhone = '05323530566';
  private readonly adminName = 'Tolga Erken';

  private constructor() {
    this.initializeMessaging();
  }

  private async initializeMessaging() {
    try {
      if (Platform.OS === 'web') {
        if (notificationFunctions.isSupported) {
          const supported = await notificationFunctions.isSupported();
          if (supported && notificationFunctions.getMessaging) {
            this.messaging = notificationFunctions.getMessaging();
          }
        }
      } else {
        if (notificationFunctions.getMessaging) {
          this.messaging = notificationFunctions.getMessaging();
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Messaging initialization hatasƒ±:', error);
    }
  }

  static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  /**
   * FCM notification izinlerini kontrol et ve iste
   */
  async requestPermissions(): Promise<NotificationPermission> {
    try {
      console.log('üì± Notification izinleri isteniyor...', { platform: Platform.OS });

      // Web platformu i√ßin
      if (Platform.OS === 'web') {
        // Web'de Notification API'sini kullan
        if (!('Notification' in window)) {
          console.warn('‚ö†Ô∏è Bu tarayƒ±cƒ± notification desteklemiyor');
          return { status: 'denied', canAskAgain: false };
        }

        if (Notification.permission === 'granted') {
          console.log('‚úÖ Web notification izni zaten verilmi≈ü');
          return { status: 'granted', canAskAgain: true };
        }

        if (Notification.permission === 'denied') {
          console.log('‚ùå Web notification izni reddedilmi≈ü');
          return { status: 'denied', canAskAgain: false };
        }

        // ƒ∞zin iste
        console.log('üîî Web notification izni isteniyor...');
        const permission = await Notification.requestPermission();
        const result: NotificationPermission = {
          status: permission === 'granted' ? 'granted' : 'denied',
          canAskAgain: permission !== 'denied'
        };
        console.log('üì± Web notification izin sonucu:', result);
        return result;
      }

      // React Native platformlarƒ± i√ßin
      if (!isFirebaseInitialized() || !this.messaging) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü');
        return { status: 'denied', canAskAgain: false };
      }

      if (!notificationFunctions.requestPermission || !notificationFunctions.AuthorizationStatus) {
        console.error('‚ùå Firebase messaging fonksiyonlarƒ± y√ºklenemedi');
        return { status: 'denied', canAskAgain: false };
      }

      // iOS ve Android i√ßin platform-specific izin isteme
      if (Platform.OS === 'ios') {
        console.log('üçé iOS notification izni isteniyor...');
        
        // iOS i√ßin √∂zel izin isteme
        const authStatus = await notificationFunctions.requestPermission(this.messaging, {
          alert: true,
          badge: true,
          sound: true,
          announcement: false,
          carPlay: false,
          criticalAlert: false,
          provisional: false,
        });
        
        const enabled =
          authStatus === notificationFunctions.AuthorizationStatus.AUTHORIZED ||
          authStatus === notificationFunctions.AuthorizationStatus.PROVISIONAL;

        const result: NotificationPermission = {
          status: enabled ? 'granted' : 'denied',
          canAskAgain: authStatus === notificationFunctions.AuthorizationStatus.NOT_DETERMINED
        };
        
        console.log('üì± iOS notification izin sonucu:', { authStatus, result });
        return result;
      } else if (Platform.OS === 'android') {
        console.log('ü§ñ Android notification izni isteniyor...');
        console.log('üîß Android Firebase messaging durumu:', {
          messagingInstance: !!this.messaging,
          requestPermissionFunction: !!notificationFunctions.requestPermission,
          AuthorizationStatus: !!notificationFunctions.AuthorizationStatus
        });
        
        // Android i√ßin izin isteme
        const authStatus = await notificationFunctions.requestPermission(this.messaging);
        console.log('üîç Android raw authStatus:', authStatus);
        console.log('üîç AuthorizationStatus enum:', {
          AUTHORIZED: notificationFunctions.AuthorizationStatus.AUTHORIZED,
          PROVISIONAL: notificationFunctions.AuthorizationStatus.PROVISIONAL,
          NOT_DETERMINED: notificationFunctions.AuthorizationStatus.NOT_DETERMINED,
          DENIED: notificationFunctions.AuthorizationStatus.DENIED
        });
        
        const enabled =
          authStatus === notificationFunctions.AuthorizationStatus.AUTHORIZED ||
          authStatus === notificationFunctions.AuthorizationStatus.PROVISIONAL;

        const result: NotificationPermission = {
          status: enabled ? 'granted' : 'denied',
          canAskAgain: authStatus === notificationFunctions.AuthorizationStatus.NOT_DETERMINED
        };
        
        console.log('üì± Android notification izin sonucu:', { 
          authStatus, 
          enabled,
          result,
          statusComparison: {
            isAuthorized: authStatus === notificationFunctions.AuthorizationStatus.AUTHORIZED,
            isProvisional: authStatus === notificationFunctions.AuthorizationStatus.PROVISIONAL,
            isNotDetermined: authStatus === notificationFunctions.AuthorizationStatus.NOT_DETERMINED,
            isDenied: authStatus === notificationFunctions.AuthorizationStatus.DENIED
          }
        });
        return result;
      }

      // Diƒüer platformlar i√ßin genel izin isteme
      const authStatus = await notificationFunctions.requestPermission(this.messaging);
      
      const enabled =
        authStatus === notificationFunctions.AuthorizationStatus.AUTHORIZED ||
        authStatus === notificationFunctions.AuthorizationStatus.PROVISIONAL;

      const result: NotificationPermission = {
        status: enabled ? 'granted' : 'denied',
        canAskAgain: authStatus === notificationFunctions.AuthorizationStatus.NOT_DETERMINED
      };
      
      console.log('üì± Genel notification izin sonucu:', { authStatus, result });
      return result;
    } catch (error) {
      console.error('‚ùå FCM permission request hatasƒ±:', error);
      return { status: 'denied', canAskAgain: false };
    }
  }


  /**
   * FCM token al
   */
  async getToken(): Promise<string | null> {
    try {
      // Web platformu i√ßin
      if (Platform.OS === 'web') {
        const permission = await this.requestPermissions();
        if (permission.status !== 'granted') {
          console.warn('Web notification izni verilmedi');
          return null;
        }

        if (!this.messaging || !notificationFunctions.getToken) {
          console.warn('‚ö†Ô∏è Web Firebase messaging mevcut deƒüil');
          return null;
        }

        const token = await notificationFunctions.getToken(this.messaging);
        this.currentToken = token;
        if (token) {
          await this.saveTokenToStorage(token);
        }
        return token;
      }

      // React Native platformlarƒ± i√ßin
      if (!isFirebaseInitialized() || !this.messaging) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü');
        return null;
      }

      const permission = await this.requestPermissions();
      console.log('üîç Token alma - permission durumu:', permission);
      if (permission.status !== 'granted') {
        console.warn('‚ö†Ô∏è FCM notification izni verilmedi, token alƒ±namƒ±yor');
        return null;
      }

      if (!notificationFunctions.getToken) {
        console.error('‚ùå Firebase getToken fonksiyonu y√ºklenemedi');
        return null;
      }

      console.log('üì± FCM token alƒ±nƒ±yor...', { platform: Platform.OS });
      const token = await notificationFunctions.getToken(this.messaging);
      console.log('üì± FCM token alƒ±ndƒ±:', { 
        hasToken: !!token, 
        tokenLength: token?.length || 0,
        tokenPreview: token ? token.substring(0, 20) + '...' : null
      });

      this.currentToken = token;
      await this.saveTokenToStorage(token);
      
      return token;
    } catch (error) {
      console.error('FCM token alma hatasƒ±:', error);
      return null;
    }
  }

  /**
   * Token'ƒ± local storage'a kaydet
   */
  private async saveTokenToStorage(token: string): Promise<void> {
    try {
      const tokenData: FCMToken = {
        token,
        platform: Platform.OS as 'ios' | 'android' | 'web',
        deviceId: Device.modelId || 'unknown',
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };

      await AsyncStorage.setItem('fcm_token', JSON.stringify(tokenData));
    } catch (error) {
      console.error('Token kaydetme hatasƒ±:', error);
    }
  }

  /**
   * Kaydedilmi≈ü token'ƒ± al
   */
  async getSavedToken(): Promise<FCMToken | null> {
    try {
      const tokenString = await AsyncStorage.getItem('fcm_token');
      if (tokenString) {
        return JSON.parse(tokenString);
      }
      return null;
    } catch (error) {
      console.error('Token okuma hatasƒ±:', error);
      return null;
    }
  }

  /**
   * FCM message listener'larƒ±nƒ± ba≈ülat
   */
  startListening(): void {
    // Web platformu i√ßin
    if (Platform.OS === 'web') {
      if (!this.messaging || !notificationFunctions.onMessage) {
        console.warn('‚ö†Ô∏è Web Firebase messaging mevcut deƒüil');
        return;
      }

      // Foreground message listener (Web)
      this.messageListener = notificationFunctions.onMessage(this.messaging, async (payload: any) => {
        console.log('üîî FCM message alƒ±ndƒ± (web foreground):', payload);
        console.log('üì± Bildirim Detaylarƒ±:', {
          title: payload.notification?.title,
          body: payload.notification?.body,
          data: payload.data,
          from: payload.from,
          messageId: payload.messageId,
          timestamp: new Date().toISOString()
        });
        this.handleForegroundMessage(payload);
      });

      console.log('‚úÖ Web FCM listener ba≈ülatƒ±ldƒ±');
      
      // Logging bilgilerini g√∂ster
      this.showNotificationLoggingInfo();
      return;
    }

    // React Native platformlarƒ± i√ßin
    if (!isFirebaseInitialized() || !this.messaging) {
      console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, listener ba≈ülatƒ±lamƒ±yor');
      return;
    }

    if (!notificationFunctions.onMessage || !notificationFunctions.onTokenRefresh || !notificationFunctions.setBackgroundMessageHandler) {
      console.error('‚ùå Firebase messaging fonksiyonlarƒ± y√ºklenemedi');
      return;
    }

    // Foreground message listener
    this.messageListener = notificationFunctions.onMessage(this.messaging, async (remoteMessage: any) => {
      console.log('üîî FCM message alƒ±ndƒ± (foreground):', remoteMessage);
      console.log('üì± Platform:', Platform.OS);
      console.log('üì± Bildirim Detaylarƒ±:', {
        title: remoteMessage.notification?.title,
        body: remoteMessage.notification?.body,
        data: remoteMessage.data,
        from: remoteMessage.from,
        messageId: remoteMessage.messageId,
        sentTime: remoteMessage.sentTime,
        ttl: remoteMessage.ttl,
        timestamp: new Date().toISOString(),
        hasNotification: !!remoteMessage.notification,
        hasData: !!remoteMessage.data,
        platform: Platform.OS
      });
      this.handleForegroundMessage(remoteMessage);
    });

    // Token refresh listener
    this.tokenRefreshListener = notificationFunctions.onTokenRefresh(this.messaging, async (token: string) => {
      console.log('FCM token yenilendi:', token);
      await this.handleTokenRefresh(token);
    });

    // Background message handler
    notificationFunctions.setBackgroundMessageHandler(this.messaging, async (remoteMessage: any) => {
      console.log('üîî FCM message alƒ±ndƒ± (background):', remoteMessage);
      console.log('üì± Background Bildirim Detaylarƒ±:', {
        title: remoteMessage.notification?.title,
        body: remoteMessage.notification?.body,
        data: remoteMessage.data,
        from: remoteMessage.from,
        messageId: remoteMessage.messageId,
        sentTime: remoteMessage.sentTime,
        ttl: remoteMessage.ttl,
        timestamp: new Date().toISOString()
      });
      this.handleBackgroundMessage(remoteMessage);
    });

    console.log('‚úÖ React Native FCM listener ba≈ülatƒ±ldƒ±');
    
    // Logging bilgilerini g√∂ster
    this.showNotificationLoggingInfo();
  }

  /**
   * FCM listener'larƒ±nƒ± durdur
   */
  stopListening(): void {
    if (this.messageListener) {
      this.messageListener();
      this.messageListener = null;
    }

    if (this.tokenRefreshListener) {
      this.tokenRefreshListener();
      this.tokenRefreshListener = null;
    }
  }

  /**
   * Foreground FCM message'ƒ±nƒ± i≈üle
   */
  private handleForegroundMessage(remoteMessage: any): void {
    // Burada custom in-app notification g√∂sterebiliriz
    // Veya notification store'u g√ºncelleyebiliriz
    console.log('‚úÖ Foreground FCM message i≈ülendi:', remoteMessage.notification?.title);
    console.log('üîç ƒ∞≈ülenen mesaj detaylarƒ±:', {
      hasNotification: !!remoteMessage.notification,
      hasData: !!remoteMessage.data,
      dataKeys: remoteMessage.data ? Object.keys(remoteMessage.data) : [],
      notificationKeys: remoteMessage.notification ? Object.keys(remoteMessage.notification) : []
    });
    
    // Yeni notification handler'ƒ± √ßaƒüƒ±r (uygulama a√ßƒ±k)
    this.handleNotification(remoteMessage, true);
    
    // Local notification olarak g√∂ster
    if (remoteMessage.notification) {
      this.showLocalNotification(
        remoteMessage.notification.title || 'Bildirim',
        remoteMessage.notification.body || '',
        remoteMessage.data
      );
    }
  }

  /**
   * Background FCM message'ƒ±nƒ± i≈üle
   */
  private handleBackgroundMessage(remoteMessage: any): void {
    console.log('‚úÖ Background FCM message i≈ülendi:', remoteMessage.notification?.title);
    console.log('üîç Background mesaj detaylarƒ±:', {
      hasNotification: !!remoteMessage.notification,
      hasData: !!remoteMessage.data,
      dataKeys: remoteMessage.data ? Object.keys(remoteMessage.data) : [],
      notificationKeys: remoteMessage.notification ? Object.keys(remoteMessage.notification) : []
    });
    
    // Yeni notification handler'ƒ± √ßaƒüƒ±r (uygulama kapalƒ±)
    this.handleNotification(remoteMessage, false);
  }

  /**
   * Token refresh'i i≈üle
   */
  private async handleTokenRefresh(token: string): Promise<void> {
    const oldToken = this.currentToken;
    this.currentToken = token;
    
    // Yeni token'ƒ± storage'a kaydet
    await this.saveTokenToStorage(token);
    
    // Token deƒüi≈üikliƒüini bildir (opsiyonel callback)
    console.log('FCM token g√ºncellendi:', { oldToken, newToken: token });
  }

  /**
   * Local notification g√∂ster (FCM message'ƒ± local olarak g√∂stermek i√ßin)
   */
  private showLocalNotification(
    title: string,
    body: string,
    data?: Record<string, any>
  ): void {
    // FCM'de local notification genellikle otomatik olarak g√∂sterilir
    // Eƒüer √∂zel bir i≈ülem gerekiyorsa burada yapƒ±labilir
    console.log('üì≤ Local notification g√∂sterildi:', { 
      title, 
      body, 
      data,
      timestamp: new Date().toISOString(),
      hasCustomData: !!data && Object.keys(data).length > 0
    });
  }

  /**
   * FCM topic'ine subscribe ol
   */
  async subscribeToTopic(topic: string): Promise<void> {
    try {
      // Web platformunda topic subscription desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda topic subscription desteklenmiyor');
        return;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        throw new Error('Firebase App ba≈ülatƒ±lmamƒ±≈ü');
      }

      if (!notificationFunctions.subscribeToTopic) {
        throw new Error('subscribeToTopic fonksiyonu y√ºklenemedi');
      }

      await notificationFunctions.subscribeToTopic(this.messaging, topic);
      console.log(`FCM topic'ine subscribe olundu: ${topic}`);
    } catch (error) {
      console.error('Topic subscribe hatasƒ±:', error);
      throw error;
    }
  }

  /**
   * FCM topic'inden unsubscribe ol
   */
  async unsubscribeFromTopic(topic: string): Promise<void> {
    try {
      // Web platformunda topic subscription desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda topic subscription desteklenmiyor');
        return;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        throw new Error('Firebase App ba≈ülatƒ±lmamƒ±≈ü');
      }

      if (!notificationFunctions.unsubscribeFromTopic) {
        throw new Error('unsubscribeFromTopic fonksiyonu y√ºklenemedi');
      }

      await notificationFunctions.unsubscribeFromTopic(this.messaging, topic);
      console.log(`FCM topic'inden unsubscribe olundu: ${topic}`);
    } catch (error) {
      console.error('Topic unsubscribe hatasƒ±:', error);
      throw error;
    }
  }

  /**
   * Notification ayarlarƒ±nƒ± al
   */
  async getSettings(): Promise<NotificationSettings> {
    try {
      const settingsString = await AsyncStorage.getItem('notification_settings');
      if (settingsString) {
        return JSON.parse(settingsString);
      }

      // Varsayƒ±lan ayarlar
      return {
        categories: {
          messages: true,
          updates: true,
          promotions: false,
        },
        sound: true,
        vibration: true,
        badge: true,
        inApp: true,
      };
    } catch (error) {
      console.error('Ayarlarƒ± okuma hatasƒ±:', error);
      return {
        categories: {},
        sound: true,
        vibration: true,
        badge: true,
        inApp: true,
      };
    }
  }

  /**
   * Notification ayarlarƒ±nƒ± kaydet
   */
  async saveSettings(settings: NotificationSettings): Promise<void> {
    try {
      await AsyncStorage.setItem('notification_settings', JSON.stringify(settings));
    } catch (error) {
      console.error('Ayarlarƒ± kaydetme hatasƒ±:', error);
    }
  }

  /**
   * Badge sayƒ±sƒ±nƒ± g√ºncelle (iOS i√ßin)
   */
  async setBadgeCount(count: number): Promise<void> {
    try {
      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized()) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, badge g√ºncellenemiyor');
        return;
      }

      if (Platform.OS === 'ios') {
        // Badge count FCM ile doƒürudan set edilemez, server-side yapƒ±lmalƒ±
        // setAPNSToken bo≈ü string ile √ßaƒürƒ±lmamalƒ± - crash'e neden oluyor
        console.log('Badge count g√ºncelleme isteƒüi:', count);
        console.log('‚ö†Ô∏è Badge count g√ºncellemesi server-side yapƒ±lmalƒ±');
      }
    } catch (error) {
      console.error('Badge g√ºncelleme hatasƒ±:', error);
    }
  }

  /**
   * FCM token'ƒ±nƒ± sil
   */
  async deleteToken(): Promise<void> {
    try {
      // Web platformunda token silme desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda token silme desteklenmiyor');
        this.currentToken = null;
        return;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, token silinemiyor');
        return;
      }

      if (!notificationFunctions.deleteToken) {
        console.error('‚ùå deleteToken fonksiyonu y√ºklenemedi');
        return;
      }

      await notificationFunctions.deleteToken(this.messaging);
      this.currentToken = null;
      console.log('FCM token silindi');
    } catch (error) {
      console.error('FCM token silme hatasƒ±:', error);
    }
  }

  /**
   * Uygulama a√ßƒ±lma nedenini kontrol et (notification'dan mƒ±?)
   */
  async getInitialNotification(): Promise<any | null> {
    try {
      // Web platformunda initial notification desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda initial notification desteklenmiyor');
        return null;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, initial notification alƒ±namƒ±yor');
        return null;
      }

      if (!notificationFunctions.getInitialNotification) {
        console.error('‚ùå getInitialNotification fonksiyonu y√ºklenemedi');
        return null;
      }

      const remoteMessage = await notificationFunctions.getInitialNotification(this.messaging);
      if (remoteMessage) {
        console.log('üöÄ Uygulama notification ile a√ßƒ±ldƒ±:', remoteMessage);
        console.log('üì± Initial Notification Detaylarƒ±:', {
          title: remoteMessage.notification?.title,
          body: remoteMessage.notification?.body,
          data: remoteMessage.data,
          from: remoteMessage.from,
          messageId: remoteMessage.messageId,
          sentTime: remoteMessage.sentTime,
          ttl: remoteMessage.ttl,
          timestamp: new Date().toISOString(),
          hasNotification: !!remoteMessage.notification,
          hasData: !!remoteMessage.data,
          dataKeys: remoteMessage.data ? Object.keys(remoteMessage.data) : []
        });
        
        // Initial notification handler'ƒ± √ßaƒüƒ±r (uygulama kapalƒ±yken a√ßƒ±ldƒ±)
        this.handleNotification(remoteMessage, false);
      } else {
        console.log('‚ÑπÔ∏è Uygulama normal ≈üekilde a√ßƒ±ldƒ± (notification ile deƒüil)');
      }
      return remoteMessage;
    } catch (error) {
      console.error('Initial notification alma hatasƒ±:', error);
      return null;
    }
  }

  /**
   * Mevcut token'ƒ± al
   */
  getCurrentToken(): string | null {
    return this.currentToken;
  }

  /**
   * Satƒ±≈ü√ßƒ± atama bildirimi g√∂nder
   */
  async sendSellerAssignmentNotification(
    sellerToken: string,
    opportunityData: {
      id: string;
      no?: string | number;
      company?: string;
      sellerName: string;
    }
  ): Promise<void> {
    try {
      console.log('üì§ Satƒ±≈ü√ßƒ± atama bildirimi g√∂nderiliyor:', {
        sellerToken: sellerToken.substring(0, 20) + '...',
        opportunityId: opportunityData.id,
        opportunityNo: opportunityData.no,
        sellerName: opportunityData.sellerName
      });

      // Local notification g√∂nder (test i√ßin)
      await this.showLocalNotification(
        'Yeni Fƒ±rsat Atandƒ±',
        `${opportunityData.no ? `#${opportunityData.no}` : ''} ${opportunityData.company || 'Yeni fƒ±rsat'} size atandƒ±.`,
        {
          type: 'seller_assignment',
          opportunityId: opportunityData.id,
          opportunityNo: opportunityData.no,
          company: opportunityData.company,
          sellerName: opportunityData.sellerName
        }
      );

      console.log('‚úÖ Satƒ±≈ü√ßƒ± atama bildirimi g√∂nderildi');
    } catch (error) {
      console.error('‚ùå Satƒ±≈ü√ßƒ± atama bildirimi g√∂nderme hatasƒ±:', error);
      // Bildirim hatasƒ± ana i≈ülemi engellemez
    }
  }

  /**
   * Admin'e satƒ±≈ü√ßƒ± atama bildirimi g√∂nder
   */
  async sendAdminSellerAssignmentNotification(
    opportunityData: {
      id: string;
      no?: string | number;
      company?: string;
      sellerName: string;
    }
  ): Promise<void> {
    try {
      console.log('üì§ Admin satƒ±≈ü√ßƒ± atama bildirimi g√∂nderiliyor:', {
        opportunityId: opportunityData.id,
        opportunityNo: opportunityData.no,
        sellerName: opportunityData.sellerName
      });

      // Local notification g√∂nder (test i√ßin)
      await this.showLocalNotification(
        'Satƒ±≈ü√ßƒ± Atandƒ±',
        `${opportunityData.sellerName} satƒ±≈ü√ßƒ±sƒ± ${opportunityData.no ? `#${opportunityData.no}` : ''} ${opportunityData.company || 'fƒ±rsata'} atandƒ±.`,
        {
          type: 'admin_seller_assignment',
          opportunityId: opportunityData.id,
          opportunityNo: opportunityData.no,
          company: opportunityData.company,
          sellerName: opportunityData.sellerName
        }
      );

      console.log('‚úÖ Admin satƒ±≈ü√ßƒ± atama bildirimi g√∂nderildi');
    } catch (error) {
      console.error('‚ùå Admin satƒ±≈ü√ßƒ± atama bildirimi g√∂nderme hatasƒ±:', error);
      // Bildirim hatasƒ± ana i≈ülemi engellemez
    }
  }

  /**
   * Email g√∂nderme fonksiyonu (Smarty API)
   */
  async sendEmail(
    recipientName: string,
    recipientEmail: string,
    subject: string,
    htmlContent: string
  ): Promise<boolean> {
    try {
      console.log('üìß Email g√∂nderiliyor:', {
        to: recipientEmail,
        subject: subject,
        recipientName: recipientName
      });

      const response = await fetch(`${this.smartyUrl}/api/mail/sendBasicMail`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'apiKey': this.apiKey
        },
        body: JSON.stringify({
          personName: recipientName,
          personMail: recipientEmail,
          subject: subject,
          text: htmlContent
        })
      });

      if (!response.ok) {
        console.error('‚ùå Email g√∂nderme hatasƒ±:', response.statusText);
        return false;
      }

      console.log(`‚úÖ Email ba≈üarƒ±yla g√∂nderildi: ${recipientEmail}`);
      return true;
    } catch (error) {
      console.error('‚ùå Email g√∂nderme hatasƒ±:', error);
      return false;
    }
  }

  /**
   * SMS g√∂nderme fonksiyonu (Smarty API)
   */
  async sendSms(
    phoneNumber: string,
    message: string
  ): Promise<boolean> {
    try {
      console.log('üì± SMS g√∂nderiliyor:', {
        to: phoneNumber,
        message: message.substring(0, 50) + '...'
      });

      const response = await fetch(`${this.smartyUrl}/api/sms/sendSms`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'apiKey': this.apiKey
        },
        body: JSON.stringify({
          gsm: phoneNumber,
          text: message
        })
      });

      if (!response.ok) {
        console.error('‚ùå SMS g√∂nderme hatasƒ±:', response.statusText);
        return false;
      }

      console.log(`‚úÖ SMS ba≈üarƒ±yla g√∂nderildi: ${phoneNumber}`);
      return true;
    } catch (error) {
      console.error('‚ùå SMS g√∂nderme hatasƒ±:', error);
      return false;
    }
  }

  /**
   * Email i√ßeriƒüi olu≈üturma fonksiyonu
   */
  private buildEmailContent(opportunity: {
    no?: string | number;
    company?: string;
    request?: string;
    name?: string;
    phone?: string;
    email?: string;
    city?: string;
    logs?: { text: string; date: Date; userName: string }[];
  }): string {
    let emailContent = `
      <p>${opportunity.no || 'Yeni'} nolu talep size atanmƒ±≈ütƒ±r</p>
      <p>L√ºtfen talep ile ilgili adƒ±mlarƒ± log olarak kayda alƒ±nƒ±z.</p>
      <p></p>
      <h3>${opportunity.company || 'Bilinmeyen ≈ûirket'}</h3>
      <p>${opportunity.request || 'Talep bilgisi belirtilmemi≈ü'}</p>
      <p>Yetkili: ${opportunity.name || 'Belirtilmemi≈ü'}</p>
      <p>Telefon: ${opportunity.phone || 'Belirtilmemi≈ü'}</p>
      <p>Email: ${opportunity.email || 'Belirtilmemi≈ü'}</p>
      <p>≈ûehir: ${opportunity.city || 'Belirtilmemi≈ü'}</p>
    `;

    // Log kayƒ±tlarƒ±nƒ± ekle
    if (opportunity.logs && opportunity.logs.length > 0) {
      let logsText = "";
      for (const log of opportunity.logs) {
        const dateStr = new Date(log.date).toLocaleDateString('tr-TR', {
          day: '2-digit',
          month: '2-digit', 
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        logsText += `<div style='margin-top:20px'>${log.text}</div><div style='font-size:10px'>${log.userName} ${dateStr}</div>`;
      }
      
      if (logsText !== '') {
        emailContent += '<h3>Log Kayƒ±tlarƒ±</h3>' + logsText;
      }
    }

    return emailContent;
  }

  /**
   * Satƒ±≈ü√ßƒ± atama i√ßin kapsamlƒ± bildirim g√∂nderme (Email + SMS + Push)
   */
  async sendComprehensiveSellerAssignmentNotification(
    sellerData: {
      name: string;
      email?: string;
      phone?: string;
      fcmToken?: string;
    },
    adminData: {
      name: string;
      email?: string;
      phone?: string;
    },
    opportunityData: {
      id: string;
      no?: string | number;
      company?: string;
      request?: string;
    }
  ): Promise<void> {
    try {
      console.log('üì§ Kapsamlƒ± satƒ±≈ü√ßƒ± atama bildirimi ba≈ülatƒ±lƒ±yor:', {
        seller: sellerData.name,
        opportunity: opportunityData.no,
        company: opportunityData.company
      });

      const emailSubject = `${opportunityData.no || 'Yeni'} - Yeni Talep Atamasƒ± (${opportunityData.company || 'Bilinmeyen ≈ûirket'})`;
      
      // HTML email i√ßeriƒüi hazƒ±rla (notification.md formatƒ±nda)
      const emailContent = this.buildEmailContent({
        no: opportunityData.no,
        company: opportunityData.company,
        request: opportunityData.request,
        name: 'Belirtilmemi≈ü', // TODO: Opportunity contact name
        phone: 'Belirtilmemi≈ü', // TODO: Opportunity contact phone
        email: 'Belirtilmemi≈ü', // TODO: Opportunity contact email
        city: 'Belirtilmemi≈ü', // TODO: Opportunity city
        logs: [] // TODO: Opportunity logs
      });

      // SMS i√ßeriƒüi hazƒ±rla (notification.md formatƒ±nda)
      const smsContent = `Yeni Talep Atamasi Yapildi, No: ${opportunityData.no || 'Yeni'} Detaylar mail ile gonderildi`;

      // Paralel olarak t√ºm bildirimleri g√∂nder
      const promises: Promise<any>[] = [];

      // Satƒ±≈ü√ßƒ±ya email g√∂nder
      if (sellerData.email) {
        promises.push(
          this.sendEmail(
            sellerData.name,
            sellerData.email,
            emailSubject,
            emailContent
          ).catch(error => {
            console.error('‚ùå Satƒ±≈ü√ßƒ±ya email g√∂nderme hatasƒ±:', error);
            return false;
          })
        );
      }

      // Satƒ±≈ü√ßƒ±ya SMS g√∂nder
      if (sellerData.phone) {
        promises.push(
          this.sendSms(sellerData.phone, smsContent).catch(error => {
            console.error('‚ùå Satƒ±≈ü√ßƒ±ya SMS g√∂nderme hatasƒ±:', error);
            return false;
          })
        );
      }

      // Satƒ±≈ü√ßƒ±ya push notification g√∂nder
      if (sellerData.fcmToken) {
        promises.push(
          this.sendSellerAssignmentNotification(
            sellerData.fcmToken,
            {
              id: opportunityData.id,
              no: opportunityData.no,
              company: opportunityData.company,
              sellerName: sellerData.name
            }
          ).catch(error => {
            console.error('‚ùå Satƒ±≈ü√ßƒ±ya push notification g√∂nderme hatasƒ±:', error);
          })
        );
      }

      // Admin'e email g√∂nder
      promises.push(
        this.sendEmail(
          this.adminName,
          this.adminEmail,
          emailSubject,
          emailContent
        ).catch(error => {
          console.error('‚ùå Admin\'e email g√∂nderme hatasƒ±:', error);
          return false;
        })
      );

      // Admin'e SMS g√∂nder
      promises.push(
        this.sendSms(this.adminPhone, smsContent).catch(error => {
          console.error('‚ùå Admin\'e SMS g√∂nderme hatasƒ±:', error);
          return false;
        })
      );

      // Admin'e push notification g√∂nder
      promises.push(
        this.sendAdminSellerAssignmentNotification({
          id: opportunityData.id,
          no: opportunityData.no,
          company: opportunityData.company,
          sellerName: sellerData.name
        }).catch(error => {
          console.error('‚ùå Admin\'e push notification g√∂nderme hatasƒ±:', error);
        })
      );

      // T√ºm bildirimleri paralel olarak g√∂nder
      await Promise.allSettled(promises);

      console.log('‚úÖ Kapsamlƒ± satƒ±≈ü√ßƒ± atama bildirimleri g√∂nderildi');
    } catch (error) {
      console.error('‚ùå Kapsamlƒ± bildirim g√∂nderme hatasƒ±:', error);
      // Bildirim hatasƒ± ana i≈ülemi engellemez
    }
  }

  /**
   * Satƒ±≈ü√ßƒ± atama bildirimi g√∂nder (notification.md formatƒ±nda)
   */
  async sendSellerAssignmentNotificationOriginal(
    seller: { name: string; mail: string; phone: string; fcmToken?: string },
    opportunity: {
      no: number;
      company: string;
      brand: string;
      request: string;
      name: string;
      phone: string;
      email: string;
      cityId: number;
      logs: { text: string; date: Date; userName: string }[];
    }
  ): Promise<void> {
    try {
      // HTML email i√ßeriƒüi hazƒ±rla
      const emailContent = this.buildEmailContent({
        no: opportunity.no,
        company: opportunity.company,
        request: opportunity.request,
        name: opportunity.name,
        phone: opportunity.phone,
        email: opportunity.email,
        city: opportunity.cityId.toString(),
        logs: opportunity.logs
      });
      
      // SMS i√ßeriƒüi hazƒ±rla  
      const smsContent = `Yeni Talep Atamasi Yapildi, No: ${opportunity.no} Detaylar mail ile gonderildi`;

      // Push notification i√ßeriƒüi hazƒ±rla
      // const pushNotification = {
      //   title: 'Yeni Talep Atamasƒ±',
      //   body: `${opportunity.no} nolu talep size atanmƒ±≈ütƒ±r - ${opportunity.company}`,
      //   data: {
      //     type: 'opportunity_assignment',
      //     opportunityNo: opportunity.no,
      //     opportunityId: opportunity.no.toString(),
      //   },
      // };

      // Paralel olarak bildirimleri g√∂nder
      const promises = [
        // Admin'e email g√∂nder
        this.sendEmail(
          this.adminName,
          this.adminEmail,
          `${opportunity.no} - Yeni Talep Atamasƒ± (${opportunity.brand})`,
          emailContent
        ),
        
        // Temsilciye email g√∂nder
        this.sendEmail(
          seller.name,
          seller.mail,
          `${opportunity.no} - Yeni Talep Atamasƒ± (${opportunity.brand})`,
          emailContent
        ),
        
        // Admin'e SMS g√∂nder
        this.sendSms(this.adminPhone, smsContent),
        
        // Temsilciye SMS g√∂nder
        this.sendSms(seller.phone, smsContent)
      ];

      // Push notification g√∂nder (FCM token varsa)
      if (seller.fcmToken) {
        promises.push(
          this.sendSellerAssignmentNotification(seller.fcmToken, {
            id: opportunity.no.toString(),
            no: opportunity.no,
            company: opportunity.company,
            sellerName: seller.name
          }).then(() => true).catch(() => false)
        );
      }

      const results = await Promise.allSettled(promises);
      
      // Sonu√ßlarƒ± logla
      results.forEach((result, index) => {
        let type = 'Unknown';
        let recipient = 'Unknown';
        
        if (index < 2) {
          type = 'Email';
          recipient = index === 0 ? 'Admin' : 'Temsilci';
        } else if (index < 4) {
          type = 'SMS';
          recipient = index === 2 ? 'Admin' : 'Temsilci';
        } else {
          type = 'Push Notification';
          recipient = 'Temsilci';
        }
        
        if (result.status === 'rejected') {
          console.error(`‚ùå ${type} ${recipient} g√∂nderimi ba≈üarƒ±sƒ±z:`, result.reason);
        } else {
          console.log(`‚úÖ ${type} ${recipient} g√∂nderimi ba≈üarƒ±lƒ±`);
        }
      });

    } catch (error) {
      console.error('‚ùå Temsilci atama bildirimi g√∂nderme hatasƒ±:', error);
    }
  }

  /**
   * Notification handler - bildirime tƒ±klandƒ±ƒüƒ±nda veya alƒ±ndƒ±ƒüƒ±nda √ßalƒ±≈üƒ±r
   */
  async handleNotification(remoteMessage: any, isAppOpen: boolean = true): Promise<void> {
    try {
      console.log('üîî Notification handler √ßalƒ±≈ütƒ±rƒ±ldƒ±:', {
        isAppOpen,
        hasData: !!remoteMessage?.data,
        dataKeys: remoteMessage?.data ? Object.keys(remoteMessage.data) : []
      });

      // Data varsa JSON'a √ßevir
      if (remoteMessage?.data) {
        try {
          // Data string ise parse et, deƒüilse direkt kullan
          let notificationData = remoteMessage.data;
          
          console.log('üîç Raw notification data:', notificationData);
          
          // Eƒüer data i√ßinde JSON string varsa parse et
          Object.keys(notificationData).forEach(key => {
            if (typeof notificationData[key] === 'string') {
              try {
                notificationData[key] = JSON.parse(notificationData[key]);
              } catch {
                // JSON deƒüilse string olarak bƒ±rak
              }
            }
          });

          // √ñzellikle fullDocument JSON string olarak geliyorsa parse et (√ßoklu escape durumu)
          if (notificationData.fullDocument && typeof notificationData.fullDocument === 'string') {
            try {
              let parsedDocument = notificationData.fullDocument;
              
              // √áoklu JSON parse (escape karakterleri i√ßin)
              let parseAttempts = 0;
              const maxAttempts = 5; // Maksimum 5 kez dene
              
              while (typeof parsedDocument === 'string' && parseAttempts < maxAttempts) {
                try {
                  const beforeParse = parsedDocument;
                  parsedDocument = JSON.parse(parsedDocument);
                  console.log(`üìÑ fullDocument parse attempt ${parseAttempts + 1}:`, {
                    before: beforeParse.substring(0, 100) + '...',
                    after: parsedDocument
                  });
                  parseAttempts++;
                } catch (parseError) {
                  console.log(`‚ùå Parse attempt ${parseAttempts + 1} failed:`, parseError);
                  break;
                }
              }
              
              notificationData.fullDocument = parsedDocument;
              console.log('‚úÖ fullDocument ba≈üarƒ±yla parse edildi:', notificationData.fullDocument);
            } catch (error) {
              console.error('‚ùå fullDocument JSON parse hatasƒ±:', error);
              console.log('üîç Raw fullDocument:', notificationData.fullDocument);
            }
          }

          console.log('üìã Final parsed notification data:', notificationData);
          console.log('üìÑ fullDocument type:', typeof notificationData.fullDocument);
          console.log('üìÑ fullDocument content:', notificationData.fullDocument);

          // fullDocument ve module kontrol√º
          if (notificationData.fullDocument && notificationData.module) {
            await this.handleModuleNotification(
              notificationData.module,
              notificationData.fullDocument,
              isAppOpen
            );
          } else {
            console.log('‚ÑπÔ∏è Notification data\'da fullDocument veya module bulunamadƒ±');
            console.log('üîç Mevcut data keys:', Object.keys(notificationData));
            console.log('üîç fullDocument var mƒ±:', !!notificationData.fullDocument);
            console.log('üîç module var mƒ±:', !!notificationData.module);
          }
        } catch (error) {
          console.error('‚ùå Notification data parse hatasƒ±:', error);
        }
      } else {
        console.log('‚ÑπÔ∏è Notification\'da data bulunamadƒ±');
      }
    } catch (error) {
      console.error('‚ùå Notification handler hatasƒ±:', error);
    }
  }

  /**
   * Module-based notification handler
   */
  private async handleModuleNotification(
    module: string,
    fullDocument: any,
    isAppOpen: boolean
  ): Promise<void> {
    console.log('üéØ Module notification handler:', { module, isAppOpen });

    switch (module) {
      case 'sale':
        await this.handleSaleNotification(fullDocument, isAppOpen);
        break;
      case 'opportunity':
        await this.handleOpportunityNotification(fullDocument, isAppOpen);
        break;
      case 'bank-transaction':
        await this.handleBankTransactionNotification(fullDocument, isAppOpen);
        break;
      default:
        console.log(`‚ö†Ô∏è Bilinmeyen module: ${module}`);
        break;
    }
  }

  /**
   * Sale module notification handler
   */
  private async handleSaleNotification(saleData: any, isAppOpen: boolean): Promise<void> {
    try {
      console.log('üí∞ Sale notification handler:', { 
        saleNo: saleData?.no, 
        isAppOpen 
      });

      if (!saleData?.no) {
        console.error('‚ùå Sale data\'da no bulunamadƒ±');
        return;
      }

      if (isAppOpen) {
        // Uygulama a√ßƒ±kken onay dialog g√∂ster
        await this.showSaleNavigationDialog(saleData);
      } else {
        // Uygulama kapalƒ±yken direkt y√∂nlendir
        await this.navigateToSale(saleData.no);
      }
    } catch (error) {
      console.error('‚ùå Sale notification handler hatasƒ±:', error);
    }
  }

  /**
   * Opportunity module notification handler
   */
  private async handleOpportunityNotification(opportunityData: any, isAppOpen: boolean): Promise<void> {
    try {
      console.log('üéØ Opportunity notification handler:', {
        opportunityNo: opportunityData?.no,
        isAppOpen
      });

      if (!opportunityData?.no && !opportunityData?.id && !opportunityData?.company) {
        console.error('‚ùå Opportunity data ge√ßersiz (no/id/company yok)');
        return;
      }

      // √ñncelik: no ‚Üí id ‚Üí company
      const searchQuery = opportunityData?.no?.toString() || opportunityData?.id || opportunityData?.company;

      if (isAppOpen) {
        await this.showOpportunityNavigationDialog(searchQuery, opportunityData);
      } else {
        await this.navigateToOpportunity(searchQuery);
      }
    } catch (error) {
      console.error('‚ùå Opportunity notification handler hatasƒ±:', error);
    }
  }

  /**
   * Fƒ±rsat y√∂nlendirme onay dialogu (uygulama a√ßƒ±kken)
   */
  private async showOpportunityNavigationDialog(searchQuery: string, opportunityData?: any): Promise<void> {
    return new Promise(async (resolve) => {
      try {
        const title = 'Fƒ±rsat Bildirimi';
        const bodyLines: string[] = [];
        if (opportunityData?.no) bodyLines.push(`Fƒ±rsat No: ${opportunityData.no}`);
        if (opportunityData?.company) bodyLines.push(`≈ûirket: ${opportunityData.company}`);
        const message = `${bodyLines.join('\n')}${bodyLines.length ? '\n\n' : ''}Bu fƒ±rsatƒ± g√∂r√ºnt√ºlemek istiyor musunuz?`;

        if (Platform.OS === 'web') {
          const canConfirm = typeof confirm === 'function';
          const userConfirmed = canConfirm ? confirm(`${title}\n\n${message}`) : true;
          if (userConfirmed) {
            console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini onayladƒ± (web)');
            await this.navigateToOpportunity(searchQuery);
          } else {
            console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini iptal etti (web)');
          }
          resolve();
        } else {
          try {
            Alert.alert(
              title,
              message,
              [
                {
                  text: 'ƒ∞ptal',
                  style: 'cancel',
                  onPress: () => {
                    console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini iptal etti');
                    resolve();
                  }
                },
                {
                  text: 'G√∂r√ºnt√ºle',
                  onPress: async () => {
                    console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini onayladƒ±');
                    await this.navigateToOpportunity(searchQuery);
                    resolve();
                  }
                }
              ]
            );
          } catch (importError) {
            console.error('‚ùå Alert import hatasƒ±:', importError);
            await this.navigateToOpportunity(searchQuery);
            resolve();
          }
        }
      } catch (error) {
        console.error('‚ùå Fƒ±rsat dialog g√∂sterme hatasƒ±:', error);
        await this.navigateToOpportunity(searchQuery);
        resolve();
      }
    });
  }

  /**
   * Fƒ±rsata y√∂nlendirme (Opportunities ekranƒ±na git ve arama yap)
   */
  private async navigateToOpportunity(searchQuery: string): Promise<void> {
    try {
      console.log('üß≠ Fƒ±rsata y√∂nlendiriliyor, arama:', searchQuery);
      const { router } = await import('expo-router');
      router.push({
        pathname: '/(drawer)/opportunities',
        params: {
          searchQuery: searchQuery?.toString?.() || String(searchQuery)
        }
      });
      console.log('‚úÖ Fƒ±rsatlar sayfasƒ±na y√∂nlendirildi');
    } catch (error) {
      console.error('‚ùå Fƒ±rsat y√∂nlendirme hatasƒ±:', error);
    }
  }

  /**
   * Satƒ±≈ü y√∂nlendirme onay dialogu (uygulama a√ßƒ±kken)
   */
  private async showSaleNavigationDialog(saleData: any): Promise<void> {
    return new Promise(async (resolve) => {
      try {
        if (Platform.OS === 'web') {
          // Web'de confirm kullan
          const canConfirm = typeof confirm === 'function';
          const userConfirmed = canConfirm ? confirm(
            `Satƒ±≈ü Bildirimi\n\nSatƒ±≈ü No: ${saleData.no}\n\nBu satƒ±≈üƒ± g√∂r√ºnt√ºlemek istiyor musunuz?`
          ) : true;
          
          if (userConfirmed) {
            console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini onayladƒ± (web)');
            await this.navigateToSale(saleData.no);
          } else {
            console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini iptal etti (web)');
          }
          resolve();
        } else {
          // React Native Alert'i g√ºvenli ≈üekilde import et
          try {
            Alert.alert(
              'Satƒ±≈ü Bildirimi',
              `Satƒ±≈ü No: ${saleData.no}\n\nBu satƒ±≈üƒ± g√∂r√ºnt√ºlemek istiyor musunuz?`,
              [
                {
                  text: 'ƒ∞ptal',
                  style: 'cancel',
                  onPress: () => {
                    console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini iptal etti');
                    resolve();
                  }
                },
                {
                  text: 'G√∂r√ºnt√ºle',
                  onPress: async () => {
                    console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini onayladƒ±');
                    await this.navigateToSale(saleData.no);
                    resolve();
                  }
                }
              ]
            );
          } catch (importError) {
            console.error('‚ùå Alert import hatasƒ±:', importError);
            // Alert import edilemezse direkt y√∂nlendir
            await this.navigateToSale(saleData.no);
            resolve();
          }
        }
      } catch (error) {
        console.error('‚ùå Alert g√∂sterme hatasƒ±:', error);
        // Hata durumunda direkt y√∂nlendir
        await this.navigateToSale(saleData.no);
        resolve();
      }
    });
  }

  /**
   * Satƒ±≈üa y√∂nlendirme (SalesScreen'e git ve arama yap)
   */
  private async navigateToSale(saleNo: string | number): Promise<void> {
    try {
      console.log('üß≠ Satƒ±≈üa y√∂nlendiriliyor:', saleNo);
      
      // Expo router kullanarak y√∂nlendir
      const { router } = await import('expo-router');
      
      // Sales sayfasƒ±na git ve arama parametresi ile
      router.push({
        pathname: '/(drawer)/sales',
        params: {
          searchQuery: saleNo.toString()
        }
      });
      
      console.log('‚úÖ Satƒ±≈ü sayfasƒ±na y√∂nlendirildi');
    } catch (error) {
      console.error('‚ùå Satƒ±≈ü y√∂nlendirme hatasƒ±:', error);
    }
  }

  /**
   * Banka hareketi module notification handler
   */
  private async handleBankTransactionNotification(transactionData: any, isAppOpen: boolean): Promise<void> {
    try {
      console.log('üè¶ Banka hareketi notification handler:', {
        id: transactionData?.id || transactionData?._id || transactionData?.no || transactionData?.transactionNo,
        isAppOpen
      });

      if (!transactionData || Object.keys(transactionData).length === 0) {
        console.error('‚ùå Banka hareketi verisi ge√ßersiz');
        return;
      }

      if (isAppOpen) {
        await this.showBankTransactionNavigationDialog(transactionData);
      } else {
        await this.navigateToBankTransaction(transactionData);
      }
    } catch (error) {
      console.error('‚ùå Banka hareketi notification handler hatasƒ±:', error);
    }
  }

  /**
   * Banka hareketi y√∂nlendirme onay dialogu (uygulama a√ßƒ±kken)
   */
  private async showBankTransactionNavigationDialog(transactionData: any): Promise<void> {
    return new Promise(async (resolve) => {
      try {
        const title = 'Banka Hareketi Bildirimi';
        const lines: string[] = [];
        const txNo = transactionData?.transactionNo || transactionData?.no || transactionData?.id || transactionData?._id;
        if (txNo) lines.push(`Hareket No: ${txNo}`);
        if (transactionData?.amount) lines.push(`Tutar: ${transactionData.amount} ${transactionData?.currency || ''}`.trim());
        if (transactionData?.company) lines.push(`≈ûirket: ${transactionData.company}`);
        if (transactionData?.opportunityNo) lines.push(`Fƒ±rsat No: ${transactionData.opportunityNo}`);
        const message = `${lines.join('\n')}${lines.length ? '\n\n' : ''}Bu banka hareketini g√∂r√ºnt√ºlemek istiyor musunuz?`;

        if (Platform.OS === 'web') {
          const canConfirm = typeof confirm === 'function';
          const userConfirmed = canConfirm ? confirm(`${title}\n\n${message}`) : true;
          if (userConfirmed) {
            console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini onayladƒ± (web)');
            await this.navigateToBankTransaction(transactionData);
          } else {
            console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini iptal etti (web)');
          }
          resolve();
        } else {
          try {
            Alert.alert(
              title,
              message,
              [
                {
                  text: 'ƒ∞ptal',
                  style: 'cancel',
                  onPress: () => {
                    console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini iptal etti');
                    resolve();
                  }
                },
                {
                  text: 'G√∂r√ºnt√ºle',
                  onPress: async () => {
                    console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini onayladƒ±');
                    await this.navigateToBankTransaction(transactionData);
                    resolve();
                  }
                }
              ]
            );
          } catch (importError) {
            console.error('‚ùå Alert import hatasƒ±:', importError);
            await this.navigateToBankTransaction(transactionData);
            resolve();
          }
        }
      } catch (error) {
        console.error('‚ùå Banka hareketi dialog g√∂sterme hatasƒ±:', error);
        await this.navigateToBankTransaction(transactionData);
        resolve();
      }
    });
  }

  /**
   * Banka hareketine y√∂nlendirme (mock detay ekranƒ±na git)
   */
  private async navigateToBankTransaction(transactionData: any): Promise<void> {
    try {
      console.log('üß≠ Banka hareketine y√∂nlendiriliyor');
      const { router } = await import('expo-router');
      router.push({
        pathname: '/(drawer)/bank-transaction-detail',
        params: {
          transactionData: JSON.stringify(transactionData)
        }
      });
      console.log('‚úÖ Banka hareketi detay ekranƒ±na y√∂nlendirildi');
    } catch (error) {
      console.error('‚ùå Banka hareketi y√∂nlendirme hatasƒ±:', error);
    }
  }

  /**
   * Test i√ßin notification handler'ƒ± manuel olarak √ßaƒüƒ±r
   */
  async testNotificationHandler(saleNo: string | number, isAppOpen: boolean = true, testFormat: 'object' | 'simple-json' | 'complex-json' = 'object'): Promise<void> {
    console.log('üß™ Test notification handler √ßaƒürƒ±lƒ±yor:', { saleNo, isAppOpen, testFormat });
    
    let testNotification;
    
    const saleData = {
      id: "182b-79eb",
      no: saleNo.toString()
    };
    
    switch (testFormat) {
      case 'object':
        // fullDocument'ƒ± obje olarak test et
        testNotification = {
          data: {
            module: 'sale',
            fullDocument: saleData
          },
          notification: {
            title: 'Yeni Satƒ±≈ü',
            body: `Satƒ±≈ü No: ${saleNo} i√ßin bildirim`
          }
        };
        break;
        
      case 'simple-json':
        // fullDocument'ƒ± basit JSON string olarak test et
        testNotification = {
          data: {
            module: 'sale',
            fullDocument: JSON.stringify(saleData)
          },
          notification: {
            title: 'Yeni Satƒ±≈ü (Simple JSON)',
            body: `Satƒ±≈ü No: ${saleNo} i√ßin bildirim (basit JSON string)`
          }
        };
        break;
        
      case 'complex-json':
        // Ger√ßek notification formatƒ±nƒ± sim√ºle et (√ßoklu escape)
        const complexFullDocument = JSON.stringify(JSON.stringify(saleData));
        testNotification = {
          data: {
            timestamp: new Date().toISOString(),
            module: 'sale',
            fullDocument: complexFullDocument,
            pushLogId: "",
            source: "kerzz-ai-backend"
          },
          notification: {
            title: 'Yeni Satƒ±≈ü (Complex JSON)',
            body: `Satƒ±≈ü No: ${saleNo} i√ßin bildirim (karma≈üƒ±k JSON string)`
          }
        };
        break;
    }

    await this.handleNotification(testNotification, isAppOpen);
  }

  /**
   * Android notification debug bilgilerini g√∂ster
   */
  async debugAndroidNotifications(): Promise<void> {
    if (Platform.OS !== 'android') {
      console.log('‚ö†Ô∏è Bu fonksiyon sadece Android i√ßin ge√ßerlidir');
      return;
    }

    console.log('ü§ñ Android Notification Debug Ba≈ülatƒ±lƒ±yor...');
    console.log('=====================================');
    
    // Firebase durumu
    console.log('üî• Firebase durumu:', {
      isInitialized: isFirebaseInitialized(),
      hasMessaging: !!this.messaging,
      hasRequestPermission: !!notificationFunctions.requestPermission,
      hasGetToken: !!notificationFunctions.getToken,
      hasOnMessage: !!notificationFunctions.onMessage
    });

    // ƒ∞zin durumu
    try {
      const permission = await this.requestPermissions();
      console.log('üì± ƒ∞zin durumu:', permission);
    } catch (error) {
      console.error('‚ùå ƒ∞zin kontrol√º hatasƒ±:', error);
    }

    // Token durumu
    try {
      const token = await this.getToken();
      console.log('üîë Token durumu:', {
        hasToken: !!token,
        tokenLength: token?.length || 0,
        tokenPreview: token ? token.substring(0, 30) + '...' : null
      });
    } catch (error) {
      console.error('‚ùå Token alma hatasƒ±:', error);
    }

    // Listener durumu
    console.log('üëÇ Listener durumu:', {
      hasMessageListener: !!this.messageListener,
      hasTokenRefreshListener: !!this.tokenRefreshListener
    });

    console.log('=====================================');
  }

  /**
   * Notification logging durumunu g√∂ster
   */
  showNotificationLoggingInfo(): void {
    console.log('üìã Notification Logging Bilgileri:');
    console.log('‚úÖ Foreground mesajlar console\'da loglanƒ±yor');
    console.log('‚úÖ Background mesajlar console\'da loglanƒ±yor');
    console.log('‚úÖ Initial notification (uygulama bildirimle a√ßƒ±lƒ±rsa) loglanƒ±yor');
    console.log('‚úÖ Token refresh olaylarƒ± loglanƒ±yor');
    console.log('‚úÖ Local notification g√∂sterim olaylarƒ± loglanƒ±yor');
    console.log('‚úÖ Notification handler sistemi aktif');
    console.log('');
    console.log('üîç Loglanacak bildirim verileri:');
    console.log('  ‚Ä¢ title: Bildirim ba≈ülƒ±ƒüƒ±');
    console.log('  ‚Ä¢ body: Bildirim i√ßeriƒüi');
    console.log('  ‚Ä¢ data: √ñzel veri (custom payload)');
    console.log('  ‚Ä¢ from: G√∂nderen bilgisi');
    console.log('  ‚Ä¢ messageId: Mesaj ID\'si');
    console.log('  ‚Ä¢ sentTime: G√∂nderilme zamanƒ±');
    console.log('  ‚Ä¢ ttl: Time to live');
    console.log('  ‚Ä¢ timestamp: Log zamanƒ±');
    console.log('');
    console.log('üéØ Test i√ßin push notification g√∂nderin ve console\'ƒ± kontrol edin!');
    console.log('üß™ Test i√ßin: NotificationService.getInstance().testNotificationHandler("12345", true/false)');
  }
}

export default NotificationService;
