import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Device from 'expo-device';
import { Alert, PermissionsAndroid, Platform } from 'react-native';
import { isFirebaseInitialized } from '../../../config/firebase';
import {
    FCMToken,
    NotificationPermission,
    NotificationSettings
} from '../types';

// Debug data interface
interface NotificationDebugData {
  id: string;
  timestamp: string;
  type: 'foreground' | 'background' | 'initial';
  platform: string;
  rawData: any;
  parsedData?: any;
  module?: string;
  fullDocument?: any;
  notification?: {
    title?: string;
    body?: string;
  };
  data?: any;
  from?: string;
  messageId?: string;
  sentTime?: number;
  ttl?: number;
}

// Platform-specific imports
let notificationFunctions: any = {};

// Platform-specific Firebase functions will be loaded dynamically
const loadFirebaseFunctions = async () => {
  if (Platform.OS === 'web') {
    // Web i√ßin Firebase Web SDK
    try {
      const firebaseMessaging = await import('firebase/messaging');
      notificationFunctions = {
        getMessaging: firebaseMessaging.getMessaging,
        getToken: firebaseMessaging.getToken,
        onMessage: firebaseMessaging.onMessage,
        isSupported: firebaseMessaging.isSupported
      };
    } catch (error) {
      console.warn('‚ö†Ô∏è Firebase Web Messaging y√ºklenemedi:', error);
    }
  } else {
    // React Native i√ßin Firebase
    try {
      const firebaseMessaging = await import('@react-native-firebase/messaging');
      notificationFunctions = {
        AuthorizationStatus: firebaseMessaging.AuthorizationStatus,
        deleteToken: firebaseMessaging.deleteToken,
        getInitialNotification: firebaseMessaging.getInitialNotification,
        getMessaging: firebaseMessaging.getMessaging,
        getToken: firebaseMessaging.getToken,
        getAPNSToken: firebaseMessaging.getAPNSToken,
        setAPNSToken: firebaseMessaging.setAPNSToken,
        registerDeviceForRemoteMessages: firebaseMessaging.registerDeviceForRemoteMessages,
        onMessage: firebaseMessaging.onMessage,
        onTokenRefresh: firebaseMessaging.onTokenRefresh,
        requestPermission: firebaseMessaging.requestPermission,
        setBackgroundMessageHandler: firebaseMessaging.setBackgroundMessageHandler,
        subscribeToTopic: firebaseMessaging.subscribeToTopic,
        unsubscribeFromTopic: firebaseMessaging.unsubscribeFromTopic
      };
    } catch (error) {
      console.warn('‚ö†Ô∏è React Native Firebase Messaging y√ºklenemedi:', error);
    }
  }
};

// Initialize functions
loadFirebaseFunctions();

class NotificationService {
  private static instance: NotificationService;
  private currentToken: string | null = null;
  private messageListener: (() => void) | null = null;
  private tokenRefreshListener: (() => void) | null = null;
  private backgroundMessageHandler: (() => void) | null = null;
  private messaging: any = null;

  // API Configuration
  private readonly smartyUrl = 'https://smarty.kerzz.com:4004';
  private readonly apiKey = '1453';
  private readonly adminEmail = 'tolga@kerzz.com';
  private readonly adminPhone = '05323530566';
  private readonly adminName = 'Tolga Erken';

  private constructor() {
    this.initializeMessaging();
    // Test fonksiyonlarƒ±nƒ± setup et
    NotificationService.setupConsoleTest();
  }

  private async initializeMessaging() {
    try {
      if (Platform.OS === 'web') {
        if (notificationFunctions.isSupported) {
          const supported = await notificationFunctions.isSupported();
          if (supported && notificationFunctions.getMessaging) {
            this.messaging = notificationFunctions.getMessaging();
          }
        }
      } else {
        if (notificationFunctions.getMessaging) {
          this.messaging = notificationFunctions.getMessaging();
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Messaging initialization hatasƒ±:', error);
    }
  }

  static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  /**
   * FCM notification izinlerini kontrol et ve iste
   */
  async requestPermissions(): Promise<NotificationPermission> {
    try {
      console.log('üì± Notification izinleri isteniyor...', { platform: Platform.OS });

      // Web platformu i√ßin
      if (Platform.OS === 'web') {
        // Web'de Notification API'sini kullan
        if (!('Notification' in window)) {
          console.warn('‚ö†Ô∏è Bu tarayƒ±cƒ± notification desteklemiyor');
          return { status: 'denied', canAskAgain: false };
        }

        if (Notification.permission === 'granted') {
          console.log('‚úÖ Web notification izni zaten verilmi≈ü');
          return { status: 'granted', canAskAgain: true };
        }

        if (Notification.permission === 'denied') {
          console.log('‚ùå Web notification izni reddedilmi≈ü');
          return { status: 'denied', canAskAgain: false };
        }

        // ƒ∞zin iste
        console.log('üîî Web notification izni isteniyor...');
        const permission = await Notification.requestPermission();
        const result: NotificationPermission = {
          status: permission === 'granted' ? 'granted' : 'denied',
          canAskAgain: permission !== 'denied'
        };
        console.log('üì± Web notification izin sonucu:', result);
        return result;
      }

      // React Native platformlarƒ± i√ßin
      if (!isFirebaseInitialized() || !this.messaging) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü');
        return { status: 'denied', canAskAgain: false };
      }

      if (!notificationFunctions.requestPermission || !notificationFunctions.AuthorizationStatus) {
        console.error('‚ùå Firebase messaging fonksiyonlarƒ± y√ºklenemedi');
        return { status: 'denied', canAskAgain: false };
      }

      // iOS ve Android i√ßin platform-specific izin isteme
      if (Platform.OS === 'ios') {
        console.log('üçé iOS notification izni isteniyor...');
        
        // iOS i√ßin √∂zel izin isteme
        const authStatus = await notificationFunctions.requestPermission(this.messaging, {
          alert: true,
          badge: true,
          sound: true,
          announcement: false,
          carPlay: false,
          criticalAlert: false,
          provisional: false,
        });
        
        const enabled =
          authStatus === notificationFunctions.AuthorizationStatus.AUTHORIZED ||
          authStatus === notificationFunctions.AuthorizationStatus.PROVISIONAL;

        const result: NotificationPermission = {
          status: enabled ? 'granted' : 'denied',
          canAskAgain: authStatus === notificationFunctions.AuthorizationStatus.NOT_DETERMINED
        };
        
        console.log('üì± iOS notification izin sonucu:', { authStatus, result });
        return result;
      } else if (Platform.OS === 'android') {
        console.log('ü§ñ Android notification izni isteniyor...');

        // Android 13+ (API 33) i√ßin √ßalƒ±≈üma zamanƒ± izni gerekir
        const apiLevel = Platform.Version as number;
        if (apiLevel >= 33) {
          try {
            const result = await PermissionsAndroid.request(
              PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS
            );

            const granted = result === PermissionsAndroid.RESULTS.GRANTED;
            const canAskAgain = result !== PermissionsAndroid.RESULTS.NEVER_ASK_AGAIN;

            const permissionResult: NotificationPermission = {
              status: granted ? 'granted' : 'denied',
              canAskAgain,
            };

            console.log('üì± Android 13+ notification izin sonucu:', {
              result,
              permissionResult,
            });

            return permissionResult;
          } catch (androidError) {
            console.error('‚ùå Android permission request hatasƒ±:', androidError);
            return { status: 'denied', canAskAgain: false };
          }
        }

        // Android 12 ve altƒ± i√ßin √ßalƒ±≈üma zamanƒ± izni yok, manifest yeterli
        console.log('‚ÑπÔ∏è Android < 13 i√ßin √ßalƒ±≈üma zamanƒ± izni gerekmiyor');
        return { status: 'granted', canAskAgain: true };
      }

      // Diƒüer platformlar i√ßin genel izin isteme
      const authStatus = await notificationFunctions.requestPermission(this.messaging);
      
      const enabled =
        authStatus === notificationFunctions.AuthorizationStatus.AUTHORIZED ||
        authStatus === notificationFunctions.AuthorizationStatus.PROVISIONAL;

      const result: NotificationPermission = {
        status: enabled ? 'granted' : 'denied',
        canAskAgain: authStatus === notificationFunctions.AuthorizationStatus.NOT_DETERMINED
      };
      
      console.log('üì± Genel notification izin sonucu:', { authStatus, result });
      return result;
    } catch (error) {
      console.error('‚ùå FCM permission request hatasƒ±:', error);
      return { status: 'denied', canAskAgain: false };
    }
  }


  /**
   * FCM token al
   */
  async getToken(): Promise<string | null> {
    try {
      console.log('üîç FCM Token alma i≈ülemi ba≈ülatƒ±lƒ±yor...', { 
        platform: Platform.OS,
        isFirebaseInitialized: isFirebaseInitialized(),
        hasMessaging: !!this.messaging,
        hasGetTokenFunction: !!notificationFunctions.getToken
      });

      // Web platformu i√ßin
      if (Platform.OS === 'web') {
        const permission = await this.requestPermissions();
        if (permission.status !== 'granted') {
          console.warn('Web notification izni verilmedi');
          return null;
        }

        if (!this.messaging || !notificationFunctions.getToken) {
          console.warn('‚ö†Ô∏è Web Firebase messaging mevcut deƒüil');
          return null;
        }

        const token = await notificationFunctions.getToken(this.messaging);
        this.currentToken = token;
        if (token) {
          await this.saveTokenToStorage(token);
        }
        return token;
      }

      // React Native platformlarƒ± i√ßin - detaylƒ± debug
      console.log('üîç Firebase durumu kontrol ediliyor...');
      if (!isFirebaseInitialized()) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü');
        console.log('üîß Firebase ba≈ülatma deneniyor...');
        
        try {
          const { initializeFirebase } = await import('../../../config/firebase');
          const initialized = await initializeFirebase();
          console.log('üîß Firebase ba≈ülatma sonucu:', initialized);
          
          if (!initialized) {
            console.error('‚ùå Firebase ba≈ülatƒ±lamadƒ±');
            return null;
          }
        } catch (initError) {
          console.error('‚ùå Firebase ba≈ülatma hatasƒ±:', initError);
          return null;
        }
      }

      if (!this.messaging) {
        console.error('‚ùå Messaging instance mevcut deƒüil');
        console.log('üîß Messaging instance olu≈üturuluyor...');
        await this.initializeMessaging();
        
        if (!this.messaging) {
          console.error('‚ùå Messaging instance olu≈üturulamadƒ±');
          return null;
        }
      }

      console.log('‚úÖ Firebase ve Messaging hazƒ±r');

      const permission = await this.requestPermissions();
      console.log('üîç Token alma - permission durumu:', permission);
      if (permission.status !== 'granted') {
        console.warn('‚ö†Ô∏è FCM notification izni verilmedi, token alƒ±namƒ±yor');
        return null;
      }

      if (!notificationFunctions.getToken) {
        console.error('‚ùå Firebase getToken fonksiyonu y√ºklenemedi');
        console.log('üîç Mevcut notification functions:', Object.keys(notificationFunctions));
        return null;
      }

      console.log('üì± FCM token alƒ±nƒ±yor...', { 
        platform: Platform.OS,
        messagingInstance: !!this.messaging,
        getTokenFunction: !!notificationFunctions.getToken
      });

      // iOS i√ßin APNS token kontrol√º ve ayarlama
      if (Platform.OS === 'ios') {
        console.log('üçé iOS i√ßin APNS token kontrol√º yapƒ±lƒ±yor...');
        
        try {
          // iOS'ta remote messages i√ßin cihazƒ± kaydet (APNS token √ºretimi i√ßin gerekli)
          if (notificationFunctions.registerDeviceForRemoteMessages) {
            try {
              await notificationFunctions.registerDeviceForRemoteMessages(this.messaging);
              console.log('üçé registerDeviceForRemoteMessages √ßaƒürƒ±ldƒ±');
            } catch (regError) {
              console.log('üçé registerDeviceForRemoteMessages hatasƒ±:', regError instanceof Error ? regError.message : String(regError));
            }
          }

          // APNS token'ƒ± kontrol et
          let apnsToken = null;
          if (notificationFunctions.getAPNSToken) {
            try {
              apnsToken = await notificationFunctions.getAPNSToken(this.messaging);
              console.log('üçé Mevcut APNS Token:', apnsToken ? 'Var' : 'Yok');
            } catch (apnsError) {
              console.log('üçé APNS Token alma hatasƒ±:', apnsError instanceof Error ? apnsError.message : String(apnsError));
            }
          }

          // APNS token yoksa, iOS sim√ºlat√∂r i√ßin √∂zel i≈ülem
          if (!apnsToken) {
            console.log('üçé APNS Token hen√ºz yok, iOS sim√ºlat√∂rde test i√ßin setAPNSToken denenecek');
            try {
              // Sadece sim√ºlat√∂rde sahte APNS token set et
              if (!Device.isDevice && notificationFunctions.setAPNSToken) {
                // 32-byte (64 hex char) sahte token √ºret
                const fakeToken = 'a'.repeat(64);
                await notificationFunctions.setAPNSToken(this.messaging, fakeToken);
                console.log('üçé setAPNSToken (fake) √ßaƒürƒ±ldƒ±');
                // Tekrar kontrol et
                try {
                  apnsToken = await notificationFunctions.getAPNSToken(this.messaging);
                  console.log('üçé set sonrasƒ± APNS Token:', apnsToken ? 'Var' : 'Yok');
                } catch {}
              } else {
                console.log('üçé Fiziksel cihaz ya da setAPNSToken mevcut deƒüil, beklemeye ge√ßiliyor');
              }
            } catch (setError) {
              console.log('üçé setAPNSToken hatasƒ±:', setError instanceof Error ? setError.message : String(setError));
            }
          }
        } catch (apnsCheckError) {
          console.log('üçé APNS token kontrol hatasƒ±:', apnsCheckError instanceof Error ? apnsCheckError.message : String(apnsCheckError));
        }
      }
      
      const token = await notificationFunctions.getToken(this.messaging);
      console.log('üì± FCM token alma sonucu:', { 
        hasToken: !!token, 
        tokenLength: token?.length || 0,
        tokenPreview: token ? token.substring(0, 20) + '...' : null,
        tokenType: typeof token
      });

      if (!token) {
        console.error('‚ùå FCM token null d√∂nd√º - detaylƒ± debug:');
        console.log('üîç Messaging instance detaylarƒ±:', {
          messaging: this.messaging,
          messagingType: typeof this.messaging,
          messagingKeys: this.messaging ? Object.keys(this.messaging) : 'N/A'
        });
        
        // APNs token kontrol√º (iOS i√ßin)
        if (Platform.OS === 'ios') {
          try {
            console.log('üçé iOS APNs token kontrol ediliyor...');
            const apnsToken = await notificationFunctions.getAPNSToken?.(this.messaging);
            console.log('üçé APNs token:', apnsToken ? 'Mevcut' : 'Yok');
          } catch (apnsError) {
            console.log('üçé APNs token hatasƒ±:', apnsError);
          }
        }
        
        return null;
      }

      this.currentToken = token;
      await this.saveTokenToStorage(token);
      
      return token;
    } catch (error) {
      console.error('‚ùå FCM token alma hatasƒ±:', error);
      console.error('‚ùå Hata detaylarƒ±:', {
        message: error instanceof Error ? error.message : String(error),
        code: error && typeof error === 'object' && 'code' in error ? error.code : 'unknown',
        stack: error instanceof Error ? error.stack?.split('\n').slice(0, 3) : undefined
      });
      
      return null;
    }
  }

  /**
   * Token'ƒ± local storage'a kaydet
   */
  private async saveTokenToStorage(token: string): Promise<void> {
    try {
      const tokenData: FCMToken = {
        token,
        platform: Platform.OS as 'ios' | 'android' | 'web',
        deviceId: Device.modelId || 'unknown',
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };

      await AsyncStorage.setItem('fcm_token', JSON.stringify(tokenData));
    } catch (error) {
      console.error('Token kaydetme hatasƒ±:', error);
    }
  }

  /**
   * Kaydedilmi≈ü token'ƒ± al
   */
  async getSavedToken(): Promise<FCMToken | null> {
    try {
      const tokenString = await AsyncStorage.getItem('fcm_token');
      if (tokenString) {
        return JSON.parse(tokenString);
      }
      return null;
    } catch (error) {
      console.error('Token okuma hatasƒ±:', error);
      return null;
    }
  }

  /**
   * FCM message listener'larƒ±nƒ± ba≈ülat
   */
  startListening(): void {
    // Web platformu i√ßin
    if (Platform.OS === 'web') {
      if (!this.messaging || !notificationFunctions.onMessage) {
        console.warn('‚ö†Ô∏è Web Firebase messaging mevcut deƒüil');
        return;
      }

      // Foreground message listener (Web)
      this.messageListener = notificationFunctions.onMessage(this.messaging, async (payload: any) => {
        console.log('üîî FCM message alƒ±ndƒ± (web foreground):', payload);
        console.log('üì± Bildirim Detaylarƒ±:', {
          title: payload.notification?.title,
          body: payload.notification?.body,
          data: payload.data,
          from: payload.from,
          messageId: payload.messageId,
          timestamp: new Date().toISOString()
        });
        this.handleForegroundMessage(payload);
      });

      console.log('‚úÖ Web FCM listener ba≈ülatƒ±ldƒ±');
      
      // Logging bilgilerini g√∂ster
      this.showNotificationLoggingInfo();
      return;
    }

    // React Native platformlarƒ± i√ßin
    if (!isFirebaseInitialized() || !this.messaging) {
      console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, listener ba≈ülatƒ±lamƒ±yor');
      return;
    }

    if (!notificationFunctions.onMessage || !notificationFunctions.onTokenRefresh || !notificationFunctions.setBackgroundMessageHandler) {
      console.error('‚ùå Firebase messaging fonksiyonlarƒ± y√ºklenemedi');
      return;
    }

    // Foreground message listener
    this.messageListener = notificationFunctions.onMessage(this.messaging, async (remoteMessage: any) => {
      console.log('üîî FCM message alƒ±ndƒ± (foreground):', remoteMessage);
      console.log('üì± Platform:', Platform.OS);
      console.log('üì± Bildirim Detaylarƒ±:', {
        title: remoteMessage.notification?.title,
        body: remoteMessage.notification?.body,
        data: remoteMessage.data,
        from: remoteMessage.from,
        messageId: remoteMessage.messageId,
        sentTime: remoteMessage.sentTime,
        ttl: remoteMessage.ttl,
        timestamp: new Date().toISOString(),
        hasNotification: !!remoteMessage.notification,
        hasData: !!remoteMessage.data,
        platform: Platform.OS
      });
      this.handleForegroundMessage(remoteMessage);
    });

    // Token refresh listener
    this.tokenRefreshListener = notificationFunctions.onTokenRefresh(this.messaging, async (token: string) => {
      console.log('FCM token yenilendi:', token);
      await this.handleTokenRefresh(token);
    });

    // Background message handler
    notificationFunctions.setBackgroundMessageHandler(this.messaging, async (remoteMessage: any) => {
      console.log('üîî FCM message alƒ±ndƒ± (background):', remoteMessage);
      console.log('üì± Background Bildirim Detaylarƒ±:', {
        title: remoteMessage.notification?.title,
        body: remoteMessage.notification?.body,
        data: remoteMessage.data,
        from: remoteMessage.from,
        messageId: remoteMessage.messageId,
        sentTime: remoteMessage.sentTime,
        ttl: remoteMessage.ttl,
        timestamp: new Date().toISOString()
      });
      this.handleBackgroundMessage(remoteMessage);
    });

    console.log('‚úÖ React Native FCM listener ba≈ülatƒ±ldƒ±');
    
    // Logging bilgilerini g√∂ster
    this.showNotificationLoggingInfo();
  }

  /**
   * FCM listener'larƒ±nƒ± durdur
   */
  stopListening(): void {
    if (this.messageListener) {
      this.messageListener();
      this.messageListener = null;
    }

    if (this.tokenRefreshListener) {
      this.tokenRefreshListener();
      this.tokenRefreshListener = null;
    }
  }

  /**
   * Foreground FCM message'ƒ±nƒ± i≈üle
   */
  private handleForegroundMessage(remoteMessage: any): void {
    // Burada custom in-app notification g√∂sterebiliriz
    // Veya notification store'u g√ºncelleyebiliriz
    console.log('‚úÖ Foreground FCM message i≈ülendi:', remoteMessage.notification?.title);
    console.log('üîç ƒ∞≈ülenen mesaj detaylarƒ±:', {
      hasNotification: !!remoteMessage.notification,
      hasData: !!remoteMessage.data,
      dataKeys: remoteMessage.data ? Object.keys(remoteMessage.data) : [],
      notificationKeys: remoteMessage.notification ? Object.keys(remoteMessage.notification) : []
    });
    
    // Debug data kaydet
    this.saveDebugData(remoteMessage, 'foreground');
    
    // Yeni notification handler'ƒ± √ßaƒüƒ±r (uygulama a√ßƒ±k)
    this.handleNotification(remoteMessage, true);
    
    // Local notification olarak g√∂ster
    if (remoteMessage.notification) {
      this.showLocalNotification(
        remoteMessage.notification.title || 'Bildirim',
        remoteMessage.notification.body || '',
        remoteMessage.data
      );
    }
  }

  /**
   * Background FCM message'ƒ±nƒ± i≈üle
   */
  private handleBackgroundMessage(remoteMessage: any): void {
    console.log('‚úÖ Background FCM message i≈ülendi:', remoteMessage.notification?.title);
    console.log('üîç Background mesaj detaylarƒ±:', {
      hasNotification: !!remoteMessage.notification,
      hasData: !!remoteMessage.data,
      dataKeys: remoteMessage.data ? Object.keys(remoteMessage.data) : [],
      notificationKeys: remoteMessage.notification ? Object.keys(remoteMessage.notification) : []
    });
    
    // Debug data kaydet
    this.saveDebugData(remoteMessage, 'background');
    
    // Yeni notification handler'ƒ± √ßaƒüƒ±r (uygulama kapalƒ±)
    this.handleNotification(remoteMessage, false);
  }

  /**
   * Token refresh'i i≈üle
   */
  private async handleTokenRefresh(token: string): Promise<void> {
    const oldToken = this.currentToken;
    this.currentToken = token;
    
    // Yeni token'ƒ± storage'a kaydet
    await this.saveTokenToStorage(token);
    
    // Token deƒüi≈üikliƒüini bildir (opsiyonel callback)
    console.log('FCM token g√ºncellendi:', { oldToken, newToken: token });
  }

  /**
   * Local notification g√∂ster (FCM message'ƒ± local olarak g√∂stermek i√ßin)
   */
  private showLocalNotification(
    title: string,
    body: string,
    data?: Record<string, any>
  ): void {
    // FCM'de local notification genellikle otomatik olarak g√∂sterilir
    // Eƒüer √∂zel bir i≈ülem gerekiyorsa burada yapƒ±labilir
    console.log('üì≤ Local notification g√∂sterildi:', { 
      title, 
      body, 
      data,
      timestamp: new Date().toISOString(),
      hasCustomData: !!data && Object.keys(data).length > 0
    });
  }

  /**
   * FCM topic'ine subscribe ol
   */
  async subscribeToTopic(topic: string): Promise<void> {
    try {
      // Web platformunda topic subscription desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda topic subscription desteklenmiyor');
        return;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        throw new Error('Firebase App ba≈ülatƒ±lmamƒ±≈ü');
      }

      if (!notificationFunctions.subscribeToTopic) {
        throw new Error('subscribeToTopic fonksiyonu y√ºklenemedi');
      }

      await notificationFunctions.subscribeToTopic(this.messaging, topic);
      console.log(`FCM topic'ine subscribe olundu: ${topic}`);
    } catch (error) {
      console.error('Topic subscribe hatasƒ±:', error);
      throw error;
    }
  }

  /**
   * FCM topic'inden unsubscribe ol
   */
  async unsubscribeFromTopic(topic: string): Promise<void> {
    try {
      // Web platformunda topic subscription desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda topic subscription desteklenmiyor');
        return;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        throw new Error('Firebase App ba≈ülatƒ±lmamƒ±≈ü');
      }

      if (!notificationFunctions.unsubscribeFromTopic) {
        throw new Error('unsubscribeFromTopic fonksiyonu y√ºklenemedi');
      }

      await notificationFunctions.unsubscribeFromTopic(this.messaging, topic);
      console.log(`FCM topic'inden unsubscribe olundu: ${topic}`);
    } catch (error) {
      console.error('Topic unsubscribe hatasƒ±:', error);
      throw error;
    }
  }

  /**
   * Notification ayarlarƒ±nƒ± al
   */
  async getSettings(): Promise<NotificationSettings> {
    try {
      const settingsString = await AsyncStorage.getItem('notification_settings');
      if (settingsString) {
        return JSON.parse(settingsString);
      }

      // Varsayƒ±lan ayarlar
      return {
        categories: {
          messages: true,
          updates: true,
          promotions: false,
        },
        sound: true,
        vibration: true,
        badge: true,
        inApp: true,
        autoRedirect: false, // Varsayƒ±lan olarak kullanƒ±cƒ±ya sor
      };
    } catch (error) {
      console.error('Ayarlarƒ± okuma hatasƒ±:', error);
      return {
        categories: {},
        sound: true,
        vibration: true,
        badge: true,
        inApp: true,
        autoRedirect: false, // Varsayƒ±lan olarak kullanƒ±cƒ±ya sor
      };
    }
  }

  /**
   * Notification ayarlarƒ±nƒ± kaydet
   */
  async saveSettings(settings: NotificationSettings): Promise<void> {
    try {
      await AsyncStorage.setItem('notification_settings', JSON.stringify(settings));
    } catch (error) {
      console.error('Ayarlarƒ± kaydetme hatasƒ±:', error);
    }
  }

  /**
   * Badge sayƒ±sƒ±nƒ± g√ºncelle (iOS i√ßin)
   */
  async setBadgeCount(count: number): Promise<void> {
    try {
      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized()) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, badge g√ºncellenemiyor');
        return;
      }

      if (Platform.OS === 'ios') {
        // Badge count FCM ile doƒürudan set edilemez, server-side yapƒ±lmalƒ±
        // setAPNSToken bo≈ü string ile √ßaƒürƒ±lmamalƒ± - crash'e neden oluyor
        console.log('Badge count g√ºncelleme isteƒüi:', count);
        console.log('‚ö†Ô∏è Badge count g√ºncellemesi server-side yapƒ±lmalƒ±');
      }
    } catch (error) {
      console.error('Badge g√ºncelleme hatasƒ±:', error);
    }
  }

  /**
   * FCM token'ƒ±nƒ± sil
   */
  async deleteToken(): Promise<void> {
    try {
      // Web platformunda token silme desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda token silme desteklenmiyor');
        this.currentToken = null;
        return;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, token silinemiyor');
        return;
      }

      if (!notificationFunctions.deleteToken) {
        console.error('‚ùå deleteToken fonksiyonu y√ºklenemedi');
        return;
      }

      await notificationFunctions.deleteToken(this.messaging);
      this.currentToken = null;
      console.log('FCM token silindi');
    } catch (error) {
      console.error('FCM token silme hatasƒ±:', error);
    }
  }

  /**
   * Uygulama a√ßƒ±lma nedenini kontrol et (notification'dan mƒ±?)
   */
  async getInitialNotification(): Promise<any | null> {
    try {
      // Web platformunda initial notification desteklenmiyor
      if (Platform.OS === 'web') {
        console.warn('‚ö†Ô∏è Web platformunda initial notification desteklenmiyor');
        return null;
      }

      // Firebase App'in ba≈ülatƒ±lƒ±p ba≈ülatƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
      if (!isFirebaseInitialized() || !this.messaging) {
        console.error('‚ùå Firebase App ba≈ülatƒ±lmamƒ±≈ü, initial notification alƒ±namƒ±yor');
        return null;
      }

      if (!notificationFunctions.getInitialNotification) {
        console.error('‚ùå getInitialNotification fonksiyonu y√ºklenemedi');
        return null;
      }

      const remoteMessage = await notificationFunctions.getInitialNotification(this.messaging);
      if (remoteMessage) {
        console.log('üöÄ Uygulama notification ile a√ßƒ±ldƒ±:', remoteMessage);
        console.log('üì± Initial Notification Detaylarƒ±:', {
          title: remoteMessage.notification?.title,
          body: remoteMessage.notification?.body,
          data: remoteMessage.data,
          from: remoteMessage.from,
          messageId: remoteMessage.messageId,
          sentTime: remoteMessage.sentTime,
          ttl: remoteMessage.ttl,
          timestamp: new Date().toISOString(),
          hasNotification: !!remoteMessage.notification,
          hasData: !!remoteMessage.data,
          dataKeys: remoteMessage.data ? Object.keys(remoteMessage.data) : []
        });
        
        // Debug data kaydet
        this.saveDebugData(remoteMessage, 'initial');
        
        // Initial notification handler'ƒ± √ßaƒüƒ±r (uygulama kapalƒ±yken a√ßƒ±ldƒ±)
        this.handleNotification(remoteMessage, false);
      } else {
        console.log('‚ÑπÔ∏è Uygulama normal ≈üekilde a√ßƒ±ldƒ± (notification ile deƒüil)');
      }
      return remoteMessage;
    } catch (error) {
      console.error('Initial notification alma hatasƒ±:', error);
      return null;
    }
  }

  /**
   * Mevcut token'ƒ± al
   */
  getCurrentToken(): string | null {
    return this.currentToken;
  }


  /**
   * Satƒ±≈ü√ßƒ± atama bildirimi g√∂nder
   */
  async sendSellerAssignmentNotification(
    sellerToken: string,
    opportunityData: {
      id: string;
      no?: string | number;
      company?: string;
      sellerName: string;
    }
  ): Promise<void> {
    try {
      console.log('üì§ Satƒ±≈ü√ßƒ± atama bildirimi g√∂nderiliyor:', {
        sellerToken: sellerToken.substring(0, 20) + '...',
        opportunityId: opportunityData.id,
        opportunityNo: opportunityData.no,
        sellerName: opportunityData.sellerName
      });

      // Local notification g√∂nder (test i√ßin)
      await this.showLocalNotification(
        'Yeni Fƒ±rsat Atandƒ±',
        `${opportunityData.no ? `#${opportunityData.no}` : ''} ${opportunityData.company || 'Yeni fƒ±rsat'} size atandƒ±.`,
        {
          type: 'seller_assignment',
          opportunityId: opportunityData.id,
          opportunityNo: opportunityData.no,
          company: opportunityData.company,
          sellerName: opportunityData.sellerName
        }
      );

      console.log('‚úÖ Satƒ±≈ü√ßƒ± atama bildirimi g√∂nderildi');
    } catch (error) {
      console.error('‚ùå Satƒ±≈ü√ßƒ± atama bildirimi g√∂nderme hatasƒ±:', error);
      // Bildirim hatasƒ± ana i≈ülemi engellemez
    }
  }

  /**
   * Admin'e satƒ±≈ü√ßƒ± atama bildirimi g√∂nder
   */
  async sendAdminSellerAssignmentNotification(
    opportunityData: {
      id: string;
      no?: string | number;
      company?: string;
      sellerName: string;
    }
  ): Promise<void> {
    try {
      console.log('üì§ Admin satƒ±≈ü√ßƒ± atama bildirimi g√∂nderiliyor:', {
        opportunityId: opportunityData.id,
        opportunityNo: opportunityData.no,
        sellerName: opportunityData.sellerName
      });

      // Local notification g√∂nder (test i√ßin)
      await this.showLocalNotification(
        'Satƒ±≈ü√ßƒ± Atandƒ±',
        `${opportunityData.sellerName} satƒ±≈ü√ßƒ±sƒ± ${opportunityData.no ? `#${opportunityData.no}` : ''} ${opportunityData.company || 'fƒ±rsata'} atandƒ±.`,
        {
          type: 'admin_seller_assignment',
          opportunityId: opportunityData.id,
          opportunityNo: opportunityData.no,
          company: opportunityData.company,
          sellerName: opportunityData.sellerName
        }
      );

      console.log('‚úÖ Admin satƒ±≈ü√ßƒ± atama bildirimi g√∂nderildi');
    } catch (error) {
      console.error('‚ùå Admin satƒ±≈ü√ßƒ± atama bildirimi g√∂nderme hatasƒ±:', error);
      // Bildirim hatasƒ± ana i≈ülemi engellemez
    }
  }

  /**
   * Email g√∂nderme fonksiyonu (Smarty API)
   */
  async sendEmail(
    recipientName: string,
    recipientEmail: string,
    subject: string,
    htmlContent: string
  ): Promise<boolean> {
    try {
      console.log('üìß Email g√∂nderiliyor:', {
        to: recipientEmail,
        subject: subject,
        recipientName: recipientName
      });

      const response = await fetch(`${this.smartyUrl}/api/mail/sendBasicMail`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'apiKey': this.apiKey
        },
        body: JSON.stringify({
          personName: recipientName,
          personMail: recipientEmail,
          subject: subject,
          text: htmlContent
        })
      });

      if (!response.ok) {
        console.error('‚ùå Email g√∂nderme hatasƒ±:', response.statusText);
        return false;
      }

      console.log(`‚úÖ Email ba≈üarƒ±yla g√∂nderildi: ${recipientEmail}`);
      return true;
    } catch (error) {
      console.error('‚ùå Email g√∂nderme hatasƒ±:', error);
      return false;
    }
  }

  /**
   * SMS g√∂nderme fonksiyonu (Smarty API)
   */
  async sendSms(
    phoneNumber: string,
    message: string
  ): Promise<boolean> {
    try {
      console.log('üì± SMS g√∂nderiliyor:', {
        to: phoneNumber,
        message: message.substring(0, 50) + '...'
      });

      const response = await fetch(`${this.smartyUrl}/api/sms/sendSms`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'apiKey': this.apiKey
        },
        body: JSON.stringify({
          gsm: phoneNumber,
          text: message
        })
      });

      if (!response.ok) {
        console.error('‚ùå SMS g√∂nderme hatasƒ±:', response.statusText);
        return false;
      }

      console.log(`‚úÖ SMS ba≈üarƒ±yla g√∂nderildi: ${phoneNumber}`);
      return true;
    } catch (error) {
      console.error('‚ùå SMS g√∂nderme hatasƒ±:', error);
      return false;
    }
  }

  /**
   * Email i√ßeriƒüi olu≈üturma fonksiyonu
   */
  private buildEmailContent(opportunity: {
    no?: string | number;
    company?: string;
    request?: string;
    name?: string;
    phone?: string;
    email?: string;
    city?: string;
    logs?: { text: string; date: Date; userName: string }[];
  }): string {
    let emailContent = `
      <p>${opportunity.no || 'Yeni'} nolu talep size atanmƒ±≈ütƒ±r</p>
      <p>L√ºtfen talep ile ilgili adƒ±mlarƒ± log olarak kayda alƒ±nƒ±z.</p>
      <p></p>
      <h3>${opportunity.company || 'Bilinmeyen ≈ûirket'}</h3>
      <p>${opportunity.request || 'Talep bilgisi belirtilmemi≈ü'}</p>
      <p>Yetkili: ${opportunity.name || 'Belirtilmemi≈ü'}</p>
      <p>Telefon: ${opportunity.phone || 'Belirtilmemi≈ü'}</p>
      <p>Email: ${opportunity.email || 'Belirtilmemi≈ü'}</p>
      <p>≈ûehir: ${opportunity.city || 'Belirtilmemi≈ü'}</p>
    `;

    // Log kayƒ±tlarƒ±nƒ± ekle
    if (opportunity.logs && opportunity.logs.length > 0) {
      let logsText = "";
      for (const log of opportunity.logs) {
        const dateStr = new Date(log.date).toLocaleDateString('tr-TR', {
          day: '2-digit',
          month: '2-digit', 
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        logsText += `<div style='margin-top:20px'>${log.text}</div><div style='font-size:10px'>${log.userName} ${dateStr}</div>`;
      }
      
      if (logsText !== '') {
        emailContent += '<h3>Log Kayƒ±tlarƒ±</h3>' + logsText;
      }
    }

    return emailContent;
  }

  /**
   * Satƒ±≈ü√ßƒ± atama i√ßin kapsamlƒ± bildirim g√∂nderme (Email + SMS + Push)
   */
  async sendComprehensiveSellerAssignmentNotification(
    sellerData: {
      name: string;
      email?: string;
      phone?: string;
      fcmToken?: string;
    },
    adminData: {
      name: string;
      email?: string;
      phone?: string;
    },
    opportunityData: {
      id: string;
      no?: string | number;
      company?: string;
      request?: string;
    }
  ): Promise<void> {
    try {
      console.log('üì§ Kapsamlƒ± satƒ±≈ü√ßƒ± atama bildirimi ba≈ülatƒ±lƒ±yor:', {
        seller: sellerData.name,
        opportunity: opportunityData.no,
        company: opportunityData.company
      });

      const emailSubject = `${opportunityData.no || 'Yeni'} - Yeni Talep Atamasƒ± (${opportunityData.company || 'Bilinmeyen ≈ûirket'})`;
      
      // HTML email i√ßeriƒüi hazƒ±rla (notification.md formatƒ±nda)
      const emailContent = this.buildEmailContent({
        no: opportunityData.no,
        company: opportunityData.company,
        request: opportunityData.request,
        name: 'Belirtilmemi≈ü', // TODO: Opportunity contact name
        phone: 'Belirtilmemi≈ü', // TODO: Opportunity contact phone
        email: 'Belirtilmemi≈ü', // TODO: Opportunity contact email
        city: 'Belirtilmemi≈ü', // TODO: Opportunity city
        logs: [] // TODO: Opportunity logs
      });

      // SMS i√ßeriƒüi hazƒ±rla (notification.md formatƒ±nda)
      const smsContent = `Yeni Talep Atamasi Yapildi, No: ${opportunityData.no || 'Yeni'} Detaylar mail ile gonderildi`;

      // Paralel olarak t√ºm bildirimleri g√∂nder
      const promises: Promise<any>[] = [];

      // Satƒ±≈ü√ßƒ±ya email g√∂nder
      if (sellerData.email) {
        promises.push(
          this.sendEmail(
            sellerData.name,
            sellerData.email,
            emailSubject,
            emailContent
          ).catch(error => {
            console.error('‚ùå Satƒ±≈ü√ßƒ±ya email g√∂nderme hatasƒ±:', error);
            return false;
          })
        );
      }

      // Satƒ±≈ü√ßƒ±ya SMS g√∂nder
      if (sellerData.phone) {
        promises.push(
          this.sendSms(sellerData.phone, smsContent).catch(error => {
            console.error('‚ùå Satƒ±≈ü√ßƒ±ya SMS g√∂nderme hatasƒ±:', error);
            return false;
          })
        );
      }

      // Satƒ±≈ü√ßƒ±ya push notification g√∂nder
      if (sellerData.fcmToken) {
        promises.push(
          this.sendSellerAssignmentNotification(
            sellerData.fcmToken,
            {
              id: opportunityData.id,
              no: opportunityData.no,
              company: opportunityData.company,
              sellerName: sellerData.name
            }
          ).catch(error => {
            console.error('‚ùå Satƒ±≈ü√ßƒ±ya push notification g√∂nderme hatasƒ±:', error);
          })
        );
      }

      // Admin'e email g√∂nder
      promises.push(
        this.sendEmail(
          this.adminName,
          this.adminEmail,
          emailSubject,
          emailContent
        ).catch(error => {
          console.error('‚ùå Admin\'e email g√∂nderme hatasƒ±:', error);
          return false;
        })
      );

      // Admin'e SMS g√∂nder
      promises.push(
        this.sendSms(this.adminPhone, smsContent).catch(error => {
          console.error('‚ùå Admin\'e SMS g√∂nderme hatasƒ±:', error);
          return false;
        })
      );

      // Admin'e push notification g√∂nder
      promises.push(
        this.sendAdminSellerAssignmentNotification({
          id: opportunityData.id,
          no: opportunityData.no,
          company: opportunityData.company,
          sellerName: sellerData.name
        }).catch(error => {
          console.error('‚ùå Admin\'e push notification g√∂nderme hatasƒ±:', error);
        })
      );

      // T√ºm bildirimleri paralel olarak g√∂nder
      await Promise.allSettled(promises);

      console.log('‚úÖ Kapsamlƒ± satƒ±≈ü√ßƒ± atama bildirimleri g√∂nderildi');
    } catch (error) {
      console.error('‚ùå Kapsamlƒ± bildirim g√∂nderme hatasƒ±:', error);
      // Bildirim hatasƒ± ana i≈ülemi engellemez
    }
  }

  /**
   * Satƒ±≈ü√ßƒ± atama bildirimi g√∂nder (notification.md formatƒ±nda)
   */
  async sendSellerAssignmentNotificationOriginal(
    seller: { name: string; mail: string; phone: string; fcmToken?: string },
    opportunity: {
      no: number;
      company: string;
      brand: string;
      request: string;
      name: string;
      phone: string;
      email: string;
      cityId: number;
      logs: { text: string; date: Date; userName: string }[];
    }
  ): Promise<void> {
    try {
      // HTML email i√ßeriƒüi hazƒ±rla
      const emailContent = this.buildEmailContent({
        no: opportunity.no,
        company: opportunity.company,
        request: opportunity.request,
        name: opportunity.name,
        phone: opportunity.phone,
        email: opportunity.email,
        city: opportunity.cityId.toString(),
        logs: opportunity.logs
      });
      
      // SMS i√ßeriƒüi hazƒ±rla  
      const smsContent = `Yeni Talep Atamasi Yapildi, No: ${opportunity.no} Detaylar mail ile gonderildi`;

      // Push notification i√ßeriƒüi hazƒ±rla
      // const pushNotification = {
      //   title: 'Yeni Talep Atamasƒ±',
      //   body: `${opportunity.no} nolu talep size atanmƒ±≈ütƒ±r - ${opportunity.company}`,
      //   data: {
      //     type: 'opportunity_assignment',
      //     opportunityNo: opportunity.no,
      //     opportunityId: opportunity.no.toString(),
      //   },
      // };

      // Paralel olarak bildirimleri g√∂nder
      const promises = [
        // Admin'e email g√∂nder
        this.sendEmail(
          this.adminName,
          this.adminEmail,
          `${opportunity.no} - Yeni Talep Atamasƒ± (${opportunity.brand})`,
          emailContent
        ),
        
        // Temsilciye email g√∂nder
        this.sendEmail(
          seller.name,
          seller.mail,
          `${opportunity.no} - Yeni Talep Atamasƒ± (${opportunity.brand})`,
          emailContent
        ),
        
        // Admin'e SMS g√∂nder
        this.sendSms(this.adminPhone, smsContent),
        
        // Temsilciye SMS g√∂nder
        this.sendSms(seller.phone, smsContent)
      ];

      // Push notification g√∂nder (FCM token varsa)
      if (seller.fcmToken) {
        promises.push(
          this.sendSellerAssignmentNotification(seller.fcmToken, {
            id: opportunity.no.toString(),
            no: opportunity.no,
            company: opportunity.company,
            sellerName: seller.name
          }).then(() => true).catch(() => false)
        );
      }

      const results = await Promise.allSettled(promises);
      
      // Sonu√ßlarƒ± logla
      results.forEach((result, index) => {
        let type = 'Unknown';
        let recipient = 'Unknown';
        
        if (index < 2) {
          type = 'Email';
          recipient = index === 0 ? 'Admin' : 'Temsilci';
        } else if (index < 4) {
          type = 'SMS';
          recipient = index === 2 ? 'Admin' : 'Temsilci';
        } else {
          type = 'Push Notification';
          recipient = 'Temsilci';
        }
        
        if (result.status === 'rejected') {
          console.error(`‚ùå ${type} ${recipient} g√∂nderimi ba≈üarƒ±sƒ±z:`, result.reason);
        } else {
          console.log(`‚úÖ ${type} ${recipient} g√∂nderimi ba≈üarƒ±lƒ±`);
        }
      });

    } catch (error) {
      console.error('‚ùå Temsilci atama bildirimi g√∂nderme hatasƒ±:', error);
    }
  }

  /**
   * Kullanƒ±cƒ±nƒ±n otomatik y√∂nlendirme ayarƒ±nƒ± kontrol et
   */
  private async shouldAutoRedirect(): Promise<boolean> {
    try {
      const settings = await this.getSettings();
      return settings.autoRedirect;
    } catch (error) {
      console.error('‚ùå Ayar kontrol√º hatasƒ±:', error);
      return false; // Hata durumunda g√ºvenli taraf - kullanƒ±cƒ±ya sor
    }
  }

  /**
   * Otomatik y√∂nlendirme ayarƒ±nƒ± deƒüi≈ütir
   */
  async setAutoRedirect(enabled: boolean): Promise<void> {
    try {
      const currentSettings = await this.getSettings();
      const newSettings = {
        ...currentSettings,
        autoRedirect: enabled
      };
      await this.saveSettings(newSettings);
      console.log(`‚úÖ Otomatik y√∂nlendirme ayarƒ± g√ºncellendi: ${enabled ? 'Aktif' : 'Pasif'}`);
    } catch (error) {
      console.error('‚ùå Otomatik y√∂nlendirme ayarƒ± g√ºncelleme hatasƒ±:', error);
    }
  }

  /**
   * Notification'dan gelen fromUserId'yi sakla
   */
  async setNotificationFromUserId(fromUserId: string): Promise<void> {
    try {
      await AsyncStorage.setItem('notification_from_user_id', fromUserId);
      console.log('üì§ Notification fromUserId kaydedildi:', fromUserId);
    } catch (error) {
      console.error('‚ùå Notification fromUserId kaydetme hatasƒ±:', error);
    }
  }

  /**
   * Saklanan fromUserId'yi al
   */
  async getNotificationFromUserId(): Promise<string | null> {
    try {
      const fromUserId = await AsyncStorage.getItem('notification_from_user_id');
      return fromUserId;
    } catch (error) {
      console.error('‚ùå Notification fromUserId alma hatasƒ±:', error);
      return null;
    }
  }

  /**
   * Saklanan fromUserId'yi temizle
   */
  async clearNotificationFromUserId(): Promise<void> {
    try {
      await AsyncStorage.removeItem('notification_from_user_id');
      console.log('üóëÔ∏è Notification fromUserId temizlendi');
    } catch (error) {
      console.error('‚ùå Notification fromUserId temizleme hatasƒ±:', error);
    }
  }

  /**
   * Test i√ßin fromUserId set etme fonksiyonu
   */
  async testSetFromUserId(fromUserId: string): Promise<void> {
    try {
      await this.setNotificationFromUserId(fromUserId);
      console.log('üß™ Test i√ßin fromUserId set edildi:', fromUserId);
      
      // Doƒürulama i√ßin tekrar oku
      const savedFromUserId = await this.getNotificationFromUserId();
      console.log('üîç Kaydedilen fromUserId doƒürulamasƒ±:', {
        setted: fromUserId,
        saved: savedFromUserId,
        isMatch: fromUserId === savedFromUserId
      });
    } catch (error) {
      console.error('‚ùå Test fromUserId set etme hatasƒ±:', error);
    }
  }

  /**
   * Console'da test etmek i√ßin global fonksiyon
   */
  static setupConsoleTest(): void {
    if (typeof window !== 'undefined') {
      (window as any).testNotificationFromUserId = async (fromUserId: string) => {
        const service = NotificationService.getInstance();
        await service.testSetFromUserId(fromUserId);
        console.log('‚úÖ Test tamamlandƒ±. ≈ûimdi satƒ±≈ü formuna gidin ve bir satƒ±≈üƒ± onaylayƒ±n.');
      };
      
      (window as any).checkNotificationFromUserId = async () => {
        const service = NotificationService.getInstance();
        const fromUserId = await service.getNotificationFromUserId();
        console.log('üîç Mevcut fromUserId:', fromUserId);
        return fromUserId;
      };
      
      (window as any).clearNotificationFromUserId = async () => {
        const service = NotificationService.getInstance();
        await service.clearNotificationFromUserId();
        console.log('üóëÔ∏è FromUserId temizlendi');
      };
      
      console.log('üß™ Test fonksiyonlarƒ± hazƒ±r:');
      console.log('- testNotificationFromUserId("user-id-123")');
      console.log('- checkNotificationFromUserId()');
      console.log('- clearNotificationFromUserId()');
      console.log('');
      console.log('üí° Birden fazla satƒ±≈ü onayƒ± testi i√ßin:');
      console.log('1. testNotificationFromUserId("test-user-456")');
      console.log('2. Satƒ±≈ü formuna gidin');
      console.log('3. Birden fazla satƒ±≈üƒ± onaylayƒ±n');
      console.log('4. Sayfadan √ßƒ±kƒ±n (√∂zet mesaj g√∂nderilecek)');
    }
  }

  /**
   * Notification handler - bildirime tƒ±klandƒ±ƒüƒ±nda veya alƒ±ndƒ±ƒüƒ±nda √ßalƒ±≈üƒ±r
   */
  async handleNotification(remoteMessage: any, isAppOpen: boolean = true): Promise<void> {
    try {
      console.log('üîî Notification handler √ßalƒ±≈ütƒ±rƒ±ldƒ±:', {
        isAppOpen,
        hasData: !!remoteMessage?.data,
        dataKeys: remoteMessage?.data ? Object.keys(remoteMessage.data) : []
      });

      // Notification data'dan fromUserId alanƒ±nƒ± √ßƒ±kar ve global olarak sakla
      if (remoteMessage?.data?.fromUserId) {
        await this.setNotificationFromUserId(remoteMessage.data.fromUserId);
        console.log('üì§ Notification fromUserId kaydedildi:', remoteMessage.data.fromUserId);
      }

      // Data varsa JSON'a √ßevir
      if (remoteMessage?.data) {
        try {
          // Data string ise parse et, deƒüilse direkt kullan
          let notificationData = remoteMessage.data;
          
          console.log('üîç Raw notification data:', notificationData);
          
          // Eƒüer data i√ßinde JSON string varsa parse et
          Object.keys(notificationData).forEach(key => {
            if (typeof notificationData[key] === 'string') {
              try {
                notificationData[key] = JSON.parse(notificationData[key]);
              } catch {
                // JSON deƒüilse string olarak bƒ±rak
              }
            }
          });

          // √ñzellikle fullDocument JSON string olarak geliyorsa parse et (√ßoklu escape durumu)
          if (notificationData.fullDocument && typeof notificationData.fullDocument === 'string') {
            try {
              let parsedDocument = notificationData.fullDocument;
              
              // √áoklu JSON parse (escape karakterleri i√ßin)
              let parseAttempts = 0;
              const maxAttempts = 5; // Maksimum 5 kez dene
              
              while (typeof parsedDocument === 'string' && parseAttempts < maxAttempts) {
                try {
                  const beforeParse = parsedDocument;
                  parsedDocument = JSON.parse(parsedDocument);
                  console.log(`üìÑ fullDocument parse attempt ${parseAttempts + 1}:`, {
                    before: beforeParse.substring(0, 100) + '...',
                    after: parsedDocument
                  });
                  parseAttempts++;
                } catch (parseError) {
                  console.log(`‚ùå Parse attempt ${parseAttempts + 1} failed:`, parseError);
                  break;
                }
              }
              
              notificationData.fullDocument = parsedDocument;
              console.log('‚úÖ fullDocument ba≈üarƒ±yla parse edildi:', notificationData.fullDocument);
            } catch (error) {
              console.error('‚ùå fullDocument JSON parse hatasƒ±:', error);
              console.log('üîç Raw fullDocument:', notificationData.fullDocument);
            }
          }

          console.log('üìã Final parsed notification data:', notificationData);
          console.log('üìÑ fullDocument type:', typeof notificationData.fullDocument);
          console.log('üìÑ fullDocument content:', notificationData.fullDocument);

          // fullDocument ve module kontrol√º
          if (notificationData.fullDocument && notificationData.module) {
            await this.handleModuleNotification(
              notificationData.module,
              notificationData.fullDocument,
              isAppOpen
            );
          } else {
            console.log('‚ÑπÔ∏è Notification data\'da fullDocument veya module bulunamadƒ±');
            console.log('üîç Mevcut data keys:', Object.keys(notificationData));
            console.log('üîç fullDocument var mƒ±:', !!notificationData.fullDocument);
            console.log('üîç module var mƒ±:', !!notificationData.module);
          }
        } catch (error) {
          console.error('‚ùå Notification data parse hatasƒ±:', error);
        }
      } else {
        console.log('‚ÑπÔ∏è Notification\'da data bulunamadƒ±');
      }
    } catch (error) {
      console.error('‚ùå Notification handler hatasƒ±:', error);
    }
  }

  /**
   * Module-based notification handler
   */
  private async handleModuleNotification(
    module: string,
    fullDocument: any,
    isAppOpen: boolean
  ): Promise<void> {
    console.log('üéØ Module notification handler:', { module, isAppOpen });

    switch (module) {
      case 'sale':
        await this.handleSaleNotification(fullDocument, isAppOpen);
        break;
      case 'opportunity':
        await this.handleOpportunityNotification(fullDocument, isAppOpen);
        break;
      case 'bank-transaction':
        await this.handleBankTransactionNotification(fullDocument, isAppOpen);
        break;
      default:
        console.log(`‚ö†Ô∏è Bilinmeyen module: ${module}`);
        break;
    }
  }

  /**
   * Sale module notification handler
   */
  private async handleSaleNotification(saleData: any, isAppOpen: boolean): Promise<void> {
    try {
      console.log('üí∞ Sale notification handler:', { 
        saleData,
        isAppOpen 
      });

      // String olarak gelen JSON'u parse et
      let parsedData = saleData;
      if (typeof saleData === 'string') {
        // √áift quoted string'i temizle: "'[...]'" -> "[...]"
        let cleanedString = saleData;
        
        try {
          // Ba≈üƒ±nda ve sonunda tek tƒ±rnak varsa kaldƒ±r
          if (cleanedString.startsWith("'") && cleanedString.endsWith("'")) {
            cleanedString = cleanedString.slice(1, -1);
            console.log('üßπ Tek tƒ±rnaklar kaldƒ±rƒ±ldƒ±:', cleanedString);
          }
          
          // Ba≈üƒ±nda ve sonunda √ßift tƒ±rnak varsa kaldƒ±r
          if (cleanedString.startsWith('"') && cleanedString.endsWith('"')) {
            cleanedString = cleanedString.slice(1, -1);
            console.log('üßπ √áift tƒ±rnaklar kaldƒ±rƒ±ldƒ±:', cleanedString);
          }
          
          parsedData = JSON.parse(cleanedString);
          console.log('üìù String JSON parse edildi:', parsedData);
        } catch (parseError) {
          console.error('‚ùå JSON parse hatasƒ±:', parseError);
          console.error('‚ùå Ge√ßersiz JSON string:', saleData);
          console.error('‚ùå Temizlenmi≈ü string:', cleanedString);
          return;
        }
      }

      // Yeni format: array of objects [{id, no}, {id, no}, ...]
      let searchQuery: string;
      
      if (Array.isArray(parsedData)) {
        // Array formatƒ±nda geliyorsa no deƒüerlerini √ßƒ±kar
        const noValues = parsedData
          .map(item => item?.no)
          .filter(no => no) // Bo≈ü deƒüerleri filtrele
          .filter((no, index, arr) => arr.indexOf(no) === index); // Duplicate'leri kaldƒ±r
        
        if (noValues.length === 0) {
          console.error('‚ùå Sale data array\'inde ge√ßerli no deƒüeri yok');
          return;
        }
        
        searchQuery = noValues.join(',');
      } else {
        // Eski format: tek obje
        if (!parsedData?.no && !parsedData?.id && !parsedData?._id) {
          console.error('‚ùå Sale data ge√ßersiz (no/id/_id yok)');
          return;
        }

        // no alanƒ± array ise virg√ºl ile birle≈ütir
        searchQuery = Array.isArray(parsedData?.no) 
          ? parsedData.no.join(',') 
          : parsedData?.no?.toString() || parsedData?.id || parsedData?._id;
      }

      console.log('üîç Sale i√ßin olu≈üturulan searchQuery:', {
        searchQuery,
        originalData: saleData,
        parsedData: parsedData,
        isArray: Array.isArray(parsedData)
      });

      if (isAppOpen) {
        // Uygulama a√ßƒ±kken - ayara g√∂re karar ver
        const shouldAutoRedirect = await this.shouldAutoRedirect();
        if (shouldAutoRedirect) {
          console.log('üöÄ Foreground notification - otomatik y√∂nlendirme (ayar aktif)');
          await this.navigateToSale(searchQuery);
        } else {
          console.log('üöÄ Foreground notification - kullanƒ±cƒ±ya onay soruluyor (ayar pasif)');
          await this.showSaleNavigationDialog(parsedData, searchQuery);
        }
      } else {
        // Uygulama kapalƒ±yken direkt y√∂nlendir
        await this.navigateToSale(searchQuery);
      }
    } catch (error) {
      console.error('‚ùå Sale notification handler hatasƒ±:', error);
    }
  }

  /**
   * Opportunity module notification handler
   */
  private async handleOpportunityNotification(opportunityData: any, isAppOpen: boolean): Promise<void> {
    try {
      console.log('üéØ Opportunity notification handler:', {
        opportunityData,
        isAppOpen
      });

      // String olarak gelen JSON'u parse et
      let parsedData = opportunityData;
      if (typeof opportunityData === 'string') {
        // √áift quoted string'i temizle: "'[...]'" -> "[...]"
        let cleanedString = opportunityData;
        
        try {
          // Ba≈üƒ±nda ve sonunda tek tƒ±rnak varsa kaldƒ±r
          if (cleanedString.startsWith("'") && cleanedString.endsWith("'")) {
            cleanedString = cleanedString.slice(1, -1);
            console.log('üßπ Opportunity tek tƒ±rnaklar kaldƒ±rƒ±ldƒ±:', cleanedString);
          }
          
          // Ba≈üƒ±nda ve sonunda √ßift tƒ±rnak varsa kaldƒ±r
          if (cleanedString.startsWith('"') && cleanedString.endsWith('"')) {
            cleanedString = cleanedString.slice(1, -1);
            console.log('üßπ Opportunity √ßift tƒ±rnaklar kaldƒ±rƒ±ldƒ±:', cleanedString);
          }
          
          parsedData = JSON.parse(cleanedString);
          console.log('üìù Opportunity string JSON parse edildi:', parsedData);
        } catch (parseError) {
          console.error('‚ùå Opportunity JSON parse hatasƒ±:', parseError);
          console.error('‚ùå Ge√ßersiz JSON string:', opportunityData);
          console.error('‚ùå Temizlenmi≈ü string:', cleanedString);
          return;
        }
      }

      // Yeni format: array of objects [{id, no}, {id, no}, ...]
      let searchQuery: string;
      
      if (Array.isArray(parsedData)) {
        // Array formatƒ±nda geliyorsa no deƒüerlerini √ßƒ±kar
        const noValues = parsedData
          .map(item => item?.no)
          .filter(no => no) // Bo≈ü deƒüerleri filtrele
          .filter((no, index, arr) => arr.indexOf(no) === index); // Duplicate'leri kaldƒ±r
        
        if (noValues.length === 0) {
          console.error('‚ùå Opportunity data array\'inde ge√ßerli no deƒüeri yok');
          return;
        }
        
        searchQuery = noValues.join(',');
      } else {
        // Eski format: tek obje
        if (!parsedData?.no && !parsedData?.id && !parsedData?._id && !parsedData?.company) {
          console.error('‚ùå Opportunity data ge√ßersiz (no/id/_id/company yok)');
          return;
        }

        // no alanƒ± array ise virg√ºl ile birle≈ütir, deƒüilse string'e √ßevir
        if (Array.isArray(parsedData?.no)) {
          searchQuery = parsedData.no.join(',');
        } else {
          // √ñncelik: no ‚Üí id ‚Üí company
          searchQuery = parsedData?.no?.toString() || parsedData?.id || parsedData?._id || parsedData?.company;
        }
      }
      
      console.log('üîç Opportunity i√ßin olu≈üturulan searchQuery:', {
        searchQuery,
        type: typeof searchQuery,
        originalData: opportunityData,
        parsedData: parsedData,
        isArray: Array.isArray(parsedData)
      });

      if (isAppOpen) {
        // Uygulama a√ßƒ±kken - ayara g√∂re karar ver
        const shouldAutoRedirect = await this.shouldAutoRedirect();
        if (shouldAutoRedirect) {
          console.log('üöÄ Foreground opportunity notification - otomatik y√∂nlendirme (ayar aktif)');
          await this.navigateToOpportunity(searchQuery);
        } else {
          console.log('üöÄ Foreground opportunity notification - kullanƒ±cƒ±ya onay soruluyor (ayar pasif)');
          await this.showOpportunityNavigationDialog(searchQuery, parsedData);
        }
      } else {
        // Uygulama kapalƒ±yken direkt y√∂nlendir
        await this.navigateToOpportunity(searchQuery);
      }
    } catch (error) {
      console.error('‚ùå Opportunity notification handler hatasƒ±:', error);
    }
  }

  /**
   * Fƒ±rsat y√∂nlendirme onay dialogu (uygulama a√ßƒ±kken)
   */
  private async showOpportunityNavigationDialog(searchQuery: string, opportunityData?: any): Promise<void> {
    return new Promise(async (resolve) => {
      try {
        const title = 'Fƒ±rsat Bildirimi';
        const bodyLines: string[] = [];
        if (opportunityData?.no) bodyLines.push(`Fƒ±rsat No: ${opportunityData.no}`);
        if (!opportunityData?.no && (opportunityData?.id || opportunityData?._id)) bodyLines.push(`Fƒ±rsat: ${opportunityData?.id || opportunityData?._id}`);
        if (opportunityData?.company) bodyLines.push(`≈ûirket: ${opportunityData.company}`);
        const message = `${bodyLines.join('\n')}${bodyLines.length ? '\n\n' : ''}Bu fƒ±rsatƒ± g√∂r√ºnt√ºlemek istiyor musunuz?`;

        if (Platform.OS === 'web') {
          const canConfirm = typeof confirm === 'function';
          const userConfirmed = canConfirm ? confirm(`${title}\n\n${message}`) : true;
          if (userConfirmed) {
            console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini onayladƒ± (web)');
            await this.navigateToOpportunity(searchQuery);
          } else {
            console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini iptal etti (web)');
          }
          resolve();
        } else {
          try {
            Alert.alert(
              title,
              message,
              [
                {
                  text: 'ƒ∞ptal',
                  style: 'cancel',
                  onPress: () => {
                    console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini iptal etti');
                    resolve();
                  }
                },
                {
                  text: 'G√∂r√ºnt√ºle',
                  onPress: async () => {
                    console.log('üì± Kullanƒ±cƒ± fƒ±rsat y√∂nlendirmesini onayladƒ±');
                    await this.navigateToOpportunity(searchQuery);
                    resolve();
                  }
                }
              ]
            );
          } catch (importError) {
            console.error('‚ùå Alert import hatasƒ±:', importError);
            await this.navigateToOpportunity(searchQuery);
            resolve();
          }
        }
      } catch (error) {
        console.error('‚ùå Fƒ±rsat dialog g√∂sterme hatasƒ±:', error);
        await this.navigateToOpportunity(searchQuery);
        resolve();
      }
    });
  }

  /**
   * Fƒ±rsata y√∂nlendirme (Opportunities ekranƒ±na git ve arama yap)
   */
  private async navigateToOpportunity(searchQuery: string): Promise<void> {
    try {
      console.log('üß≠ Fƒ±rsata y√∂nlendiriliyor:', {
        searchQuery,
        type: typeof searchQuery,
        length: searchQuery?.length,
        stringified: searchQuery?.toString?.() || String(searchQuery)
      });
      const { router } = await import('expo-router');
      
      const finalSearchQuery = searchQuery?.toString?.() || String(searchQuery);
      console.log('üì§ Router\'a g√∂nderilen params:', {
        pathname: '/(drawer)/opportunities',
        params: { searchQuery: finalSearchQuery }
      });
      
      router.push({
        pathname: '/(drawer)/opportunities',
        params: {
          searchQuery: finalSearchQuery
        }
      });
      console.log('‚úÖ Fƒ±rsatlar sayfasƒ±na y√∂nlendirildi');
    } catch (error) {
      console.error('‚ùå Fƒ±rsat y√∂nlendirme hatasƒ±:', error);
    }
  }

  /**
   * Satƒ±≈ü y√∂nlendirme onay dialogu (uygulama a√ßƒ±kken)
   */
  private async showSaleNavigationDialog(saleData: any, searchQuery?: string): Promise<void> {
    return new Promise(async (resolve) => {
      try {
        if (Platform.OS === 'web') {
          // Web'de confirm kullan
          const canConfirm = typeof confirm === 'function';
          let displayKey = searchQuery;
          
          if (!displayKey) {
            if (Array.isArray(saleData)) {
              // Yeni format: array of objects
              const noValues = saleData.map(item => item?.no).filter(no => no);
              displayKey = noValues.join(',');
            } else {
              // Eski format: tek obje
              displayKey = Array.isArray(saleData?.no) ? saleData.no.join(',') : saleData?.no ?? saleData?.id ?? saleData?._id;
            }
          }
          
          const userConfirmed = canConfirm ? confirm(
            `Satƒ±≈ü Bildirimi\n\nSatƒ±≈ü: ${displayKey}\n\nBu satƒ±≈üƒ± g√∂r√ºnt√ºlemek istiyor musunuz?`
          ) : true;
          
          if (userConfirmed) {
            console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini onayladƒ± (web)');
            await this.navigateToSale(searchQuery || displayKey || '');
          } else {
            console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini iptal etti (web)');
          }
          resolve();
        } else {
          // React Native Alert'i g√ºvenli ≈üekilde import et
          try {
            let displayKey = searchQuery;
            
            if (!displayKey) {
              if (Array.isArray(saleData)) {
                // Yeni format: array of objects
                const noValues = saleData.map(item => item?.no).filter(no => no);
                displayKey = noValues.join(',');
              } else {
                // Eski format: tek obje
                displayKey = Array.isArray(saleData?.no) ? saleData.no.join(',') : saleData?.no ?? saleData?.id ?? saleData?._id;
              }
            }
            
            Alert.alert(
              'Satƒ±≈ü Bildirimi',
              `Satƒ±≈ü: ${displayKey}\n\nBu satƒ±≈üƒ± g√∂r√ºnt√ºlemek istiyor musunuz?`,
              [
                {
                  text: 'ƒ∞ptal',
                  style: 'cancel',
                  onPress: () => {
                    console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini iptal etti');
                    resolve();
                  }
                },
                {
                  text: 'G√∂r√ºnt√ºle',
                  onPress: async () => {
                    console.log('üì± Kullanƒ±cƒ± satƒ±≈ü y√∂nlendirmesini onayladƒ±');
                    await this.navigateToSale(searchQuery || displayKey || '');
                    resolve();
                  }
                }
              ]
            );
          } catch (importError) {
            console.error('‚ùå Alert import hatasƒ±:', importError);
            // Alert import edilemezse direkt y√∂nlendir
            let fallbackKey = searchQuery;
            if (!fallbackKey) {
              if (Array.isArray(saleData)) {
                const noValues = saleData.map(item => item?.no).filter(no => no);
                fallbackKey = noValues.join(',');
              } else {
                fallbackKey = Array.isArray(saleData?.no) ? saleData.no.join(',') : saleData?.no ?? saleData?.id ?? saleData?._id;
              }
            }
            await this.navigateToSale(fallbackKey || '');
            resolve();
          }
        }
      } catch (error) {
        console.error('‚ùå Alert g√∂sterme hatasƒ±:', error);
        // Hata durumunda direkt y√∂nlendir
        let fallbackKey = searchQuery;
        if (!fallbackKey) {
          if (Array.isArray(saleData)) {
            const noValues = saleData.map(item => item?.no).filter(no => no);
            fallbackKey = noValues.join(',');
          } else {
            fallbackKey = Array.isArray(saleData?.no) ? saleData.no.join(',') : saleData?.no ?? saleData?.id ?? saleData?._id;
          }
        }
        await this.navigateToSale(fallbackKey || '');
        resolve();
      }
    });
  }

  /**
   * Satƒ±≈üa y√∂nlendirme (SalesScreen'e git ve arama yap)
   */
  private async navigateToSale(saleNo: string | number): Promise<void> {
    try {
      console.log('üß≠ Satƒ±≈üa y√∂nlendiriliyor:', saleNo);
      
      // Expo router kullanarak y√∂nlendir
      const { router } = await import('expo-router');
      
      // Sales sayfasƒ±na git ve arama parametresi ile
      router.push({
        pathname: '/(drawer)/sales',
        params: {
          searchQuery: saleNo.toString()
        }
      });
      
      console.log('‚úÖ Satƒ±≈ü sayfasƒ±na y√∂nlendirildi');
    } catch (error) {
      console.error('‚ùå Satƒ±≈ü y√∂nlendirme hatasƒ±:', error);
    }
  }

  /**
   * Banka hareketi module notification handler
   */
  private async handleBankTransactionNotification(transactionData: any, isAppOpen: boolean): Promise<void> {
    try {
      console.log('üè¶ Banka hareketi notification handler:', {
        id: transactionData?.id || transactionData?._id,
        isAppOpen
      });

      // String olarak gelen JSON'u parse et
      let parsedData = transactionData;
      if (typeof transactionData === 'string') {
        try {
          // Ba≈üƒ±nda ve sonunda tek tƒ±rnak varsa kaldƒ±r
          let cleanedString = transactionData;
          if (cleanedString.startsWith("'") && cleanedString.endsWith("'")) {
            cleanedString = cleanedString.slice(1, -1);
          }
          
          // Ba≈üƒ±nda ve sonunda √ßift tƒ±rnak varsa kaldƒ±r
          if (cleanedString.startsWith('"') && cleanedString.endsWith('"')) {
            cleanedString = cleanedString.slice(1, -1);
          }
          
          parsedData = JSON.parse(cleanedString);
          console.log('üìù Bank transaction string JSON parse edildi:', parsedData);
        } catch (parseError) {
          console.error('‚ùå Bank transaction JSON parse hatasƒ±:', parseError);
          console.error('‚ùå Ge√ßersiz JSON string:', transactionData);
          return;
        }
      }

      if (!parsedData || Object.keys(parsedData).length === 0) {
        console.error('‚ùå Banka hareketi verisi ge√ßersiz');
        return;
      }

      // Transaction ID'sini belirle
      const transactionId = parsedData?.id || parsedData?._id;
      
      if (!transactionId) {
        console.error('‚ùå Banka hareketi ID\'si bulunamadƒ±');
        return;
      }

      console.log('üîç Bank transaction i√ßin olu≈üturulan ID:', {
        transactionId,
        originalData: transactionData,
        parsedData: parsedData
      });

      if (isAppOpen) {
        // Uygulama a√ßƒ±kken - ayara g√∂re karar ver
        const shouldAutoRedirect = await this.shouldAutoRedirect();
        if (shouldAutoRedirect) {
          console.log('üöÄ Foreground bank transaction notification - otomatik y√∂nlendirme (ayar aktif)');
          await this.navigateToBankTransactionsList(transactionId);
        } else {
          console.log('üöÄ Foreground bank transaction notification - kullanƒ±cƒ±ya onay soruluyor (ayar pasif)');
          await this.showBankTransactionNavigationDialog(parsedData);
        }
      } else {
        // Uygulama kapalƒ±yken direkt y√∂nlendir
        await this.navigateToBankTransactionsList(transactionId);
      }
    } catch (error) {
      console.error('‚ùå Banka hareketi notification handler hatasƒ±:', error);
    }
  }

  /**
   * Banka hareketi y√∂nlendirme onay dialogu (uygulama a√ßƒ±kken)
   */
  private async showBankTransactionNavigationDialog(transactionData: any): Promise<void> {
    return new Promise(async (resolve) => {
      try {
        const title = 'Banka Hareketi Bildirimi';
        const lines: string[] = [];
        const txNo = transactionData?.id || transactionData?._id;
        if (txNo) lines.push(`Hareket No: ${txNo}`);
        if (transactionData?.amount) lines.push(`Tutar: ${transactionData.amount} ${transactionData?.currency || ''}`.trim());
        if (transactionData?.company) lines.push(`≈ûirket: ${transactionData.company}`);
        if (transactionData?.opportunityNo) lines.push(`Fƒ±rsat No: ${transactionData.opportunityNo}`);
        const message = `${lines.join('\n')}${lines.length ? '\n\n' : ''}Bu banka hareketini g√∂r√ºnt√ºlemek istiyor musunuz?`;

        if (Platform.OS === 'web') {
          const canConfirm = typeof confirm === 'function';
          const userConfirmed = canConfirm ? confirm(`${title}\n\n${message}`) : true;
          if (userConfirmed) {
            console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini onayladƒ± (web)');
            const transactionId = transactionData?.id || transactionData?._id;
            if (transactionId) {
              await this.navigateToBankTransactionsList(transactionId);
            }
          } else {
            console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini iptal etti (web)');
          }
          resolve();
        } else {
          try {
            Alert.alert(
              title,
              message,
              [
                {
                  text: 'ƒ∞ptal',
                  style: 'cancel',
                  onPress: () => {
                    console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini iptal etti');
                    resolve();
                  }
                },
                {
                  text: 'G√∂r√ºnt√ºle',
                  onPress: async () => {
                    console.log('üì± Kullanƒ±cƒ± banka hareketi y√∂nlendirmesini onayladƒ±');
                    const transactionId = transactionData?.id || transactionData?._id;
                    if (transactionId) {
                      await this.navigateToBankTransactionsList(transactionId);
                    }
                    resolve();
                  }
                }
              ]
            );
          } catch (importError) {
            console.error('‚ùå Alert import hatasƒ±:', importError);
            const transactionId = transactionData?.id || transactionData?._id;
            if (transactionId) {
              await this.navigateToBankTransactionsList(transactionId);
            }
            resolve();
          }
        }
      } catch (error) {
        console.error('‚ùå Banka hareketi dialog g√∂sterme hatasƒ±:', error);
        const transactionId = transactionData?.id || transactionData?._id;
        if (transactionId) {
          await this.navigateToBankTransactionsList(transactionId);
        }
        resolve();
      }
    });
  }

  /**
   * Banka hareketi listesine y√∂nlendirme (bank-transactions ekranƒ±na git ve ilgili transaction'a scroll yap)
   */
  private async navigateToBankTransactionsList(transactionId: string): Promise<void> {
    try {
      console.log('üß≠ Banka hareketi listesine y√∂nlendiriliyor:', {
        transactionId,
        type: typeof transactionId,
        length: transactionId?.length
      });
      
      const { router } = await import('expo-router');
      
      const finalTransactionId = transactionId?.toString?.() || String(transactionId);
      console.log('üì§ Router\'a g√∂nderilen params:', {
        pathname: '/(drawer)/bank-transactions',
        params: { scrollToTransactionId: finalTransactionId }
      });
      
      // Her zaman replace kullan - bu sayede aynƒ± sayfadayken de parametreler g√ºncellenir
      console.log('üîÑ Router replace kullanƒ±lƒ±yor (parametreleri g√ºncellemek i√ßin)');
      router.replace({
        pathname: '/(drawer)/bank-transactions',
        params: {
          scrollToTransactionId: finalTransactionId,
          timestamp: Date.now().toString() // Cache busting i√ßin
        }
      });
      
      console.log('‚úÖ Banka hareketi listesine y√∂nlendirildi');
    } catch (error) {
      console.error('‚ùå Banka hareketi liste y√∂nlendirme hatasƒ±:', error);
    }
  }

  /**
   * Banka hareketine y√∂nlendirme (detay ekranƒ±na git - eski fonksiyon)
   */
  private async navigateToBankTransaction(transactionData: any): Promise<void> {
    try {
      console.log('üß≠ Banka hareketine y√∂nlendiriliyor');
      const { router } = await import('expo-router');
      router.push({
        pathname: '/(drawer)/bank-transaction-detail',
        params: {
          transactionData: JSON.stringify(transactionData)
        }
      });
      console.log('‚úÖ Banka hareketi detay ekranƒ±na y√∂nlendirildi');
    } catch (error) {
      console.error('‚ùå Banka hareketi y√∂nlendirme hatasƒ±:', error);
    }
  }

  /**
   * Test i√ßin notification handler'ƒ± manuel olarak √ßaƒüƒ±r
   */
  async testNotificationHandler(saleNo: string | number, isAppOpen: boolean = true, testFormat: 'object' | 'simple-json' | 'complex-json' = 'object'): Promise<void> {
    console.log('üß™ Test notification handler √ßaƒürƒ±lƒ±yor:', { saleNo, isAppOpen, testFormat });
    
    let testNotification;
    
    const saleData = {
      id: "182b-79eb",
      no: saleNo.toString()
    };
    
    switch (testFormat) {
      case 'object':
        // fullDocument'ƒ± obje olarak test et
        testNotification = {
          data: {
            module: 'sale',
            fullDocument: saleData
          },
          notification: {
            title: 'Yeni Satƒ±≈ü',
            body: `Satƒ±≈ü No: ${saleNo} i√ßin bildirim`
          }
        };
        break;
        
      case 'simple-json':
        // fullDocument'ƒ± basit JSON string olarak test et
        testNotification = {
          data: {
            module: 'sale',
            fullDocument: JSON.stringify(saleData)
          },
          notification: {
            title: 'Yeni Satƒ±≈ü (Simple JSON)',
            body: `Satƒ±≈ü No: ${saleNo} i√ßin bildirim (basit JSON string)`
          }
        };
        break;
        
      case 'complex-json':
        // Ger√ßek notification formatƒ±nƒ± sim√ºle et (√ßoklu escape)
        const complexFullDocument = JSON.stringify(JSON.stringify(saleData));
        testNotification = {
          data: {
            timestamp: new Date().toISOString(),
            module: 'sale',
            fullDocument: complexFullDocument,
            pushLogId: "",
            source: "kerzz-ai-backend"
          },
          notification: {
            title: 'Yeni Satƒ±≈ü (Complex JSON)',
            body: `Satƒ±≈ü No: ${saleNo} i√ßin bildirim (karma≈üƒ±k JSON string)`
          }
        };
        break;
    }

    await this.handleNotification(testNotification, isAppOpen);
  }

  /**
   * Test i√ßin bank transaction notification handler'ƒ± manuel olarak √ßaƒüƒ±r
   */
  async testBankTransactionNotificationHandler(transactionId: string, isAppOpen: boolean = true, testFormat: 'object' | 'simple-json' | 'complex-json' = 'object'): Promise<void> {
    console.log('üß™ Test bank transaction notification handler √ßaƒürƒ±lƒ±yor:', { transactionId, isAppOpen, testFormat });
    
    let testNotification;
    
    const transactionData = {
      id: transactionId,
      accounId: "acc-123",
      name: "Test Banka Hareketi",
      dc: "C",
      code: "TRF",
      amount: 1500.00,
      balance: 25000.00,
      description: "Test notification i√ßin √∂rnek banka hareketi",
      businessDate: new Date(),
      createDate: new Date(),
      opponentId: "opp-456",
      opponentIban: "TR123456789012345678901234",
      sourceId: "src-789",
      source: "API",
      bankAccId: "bank-acc-123",
      bankAccName: "Test Banka Hesabƒ±",
      bankId: "bank-001",
      bankName: "Test Bankasƒ±",
      erpStatus: "waiting" as const,
      erpMessage: "",
      erpGlAccountCode: "120.01",
      erpAccountCode: "120.01.001"
    };
    
    switch (testFormat) {
      case 'object':
        // fullDocument'ƒ± obje olarak test et
        testNotification = {
          data: {
            module: 'bank-transaction',
            fullDocument: transactionData
          },
          notification: {
            title: 'Yeni Banka Hareketi',
            body: `${transactionData.amount} TL tutarƒ±nda yeni i≈ülem`
          }
        };
        break;
        
      case 'simple-json':
        // fullDocument'ƒ± basit JSON string olarak test et
        testNotification = {
          data: {
            module: 'bank-transaction',
            fullDocument: JSON.stringify(transactionData)
          },
          notification: {
            title: 'Yeni Banka Hareketi (Simple JSON)',
            body: `${transactionData.amount} TL tutarƒ±nda yeni i≈ülem (basit JSON string)`
          }
        };
        break;
        
      case 'complex-json':
        // Ger√ßek notification formatƒ±nƒ± sim√ºle et (√ßoklu escape)
        const complexFullDocument = JSON.stringify(JSON.stringify(transactionData));
        testNotification = {
          data: {
            timestamp: new Date().toISOString(),
            module: 'bank-transaction',
            fullDocument: complexFullDocument,
            pushLogId: "",
            source: "kerzz-ai-backend"
          },
          notification: {
            title: 'Yeni Banka Hareketi (Complex JSON)',
            body: `${transactionData.amount} TL tutarƒ±nda yeni i≈ülem (karma≈üƒ±k JSON string)`
          }
        };
        break;
    }

    await this.handleNotification(testNotification, isAppOpen);
  }

  /**
   * Test i√ßin opportunity notification handler'ƒ± manuel olarak √ßaƒüƒ±r
   */
  async testOpportunityNotificationHandler(opportunityNo: string | number, isAppOpen: boolean = true, testFormat: 'object' | 'simple-json' | 'complex-json' | 'wrong-format' = 'object'): Promise<void> {
    console.log('üß™ Test opportunity notification handler √ßaƒürƒ±lƒ±yor:', { opportunityNo, isAppOpen, testFormat });
    
    let testNotification;
    
    const opportunityData = {
      id: "opp-182b-79eb",
      no: opportunityNo.toString(),
      company: "Test ≈ûirketi A.≈û."
    };
    
    // Yanlƒ±≈ü format testi - 'no' string literal olarak geliyor
    const wrongOpportunityData = {
      id: "opp-182b-79eb",
      no: "no", // Bu yanlƒ±≈ü format - string literal 'no'
      company: "Test ≈ûirketi A.≈û."
    };
    
    switch (testFormat) {
      case 'object':
        // fullDocument'ƒ± obje olarak test et
        testNotification = {
          data: {
            module: 'opportunity',
            fullDocument: opportunityData
          },
          notification: {
            title: 'Yeni Fƒ±rsat',
            body: `Fƒ±rsat No: ${opportunityNo} i√ßin bildirim`
          }
        };
        break;
        
      case 'simple-json':
        // fullDocument'ƒ± basit JSON string olarak test et
        testNotification = {
          data: {
            module: 'opportunity',
            fullDocument: JSON.stringify(opportunityData)
          },
          notification: {
            title: 'Yeni Fƒ±rsat (Simple JSON)',
            body: `Fƒ±rsat No: ${opportunityNo} i√ßin bildirim (basit JSON string)`
          }
        };
        break;
        
      case 'complex-json':
        // Ger√ßek notification formatƒ±nƒ± sim√ºle et (√ßoklu escape)
        const complexFullDocument = JSON.stringify(JSON.stringify(opportunityData));
        testNotification = {
          data: {
            timestamp: new Date().toISOString(),
            module: 'opportunity',
            fullDocument: complexFullDocument,
            pushLogId: "",
            source: "kerzz-ai-backend"
          },
          notification: {
            title: 'Yeni Fƒ±rsat (Complex JSON)',
            body: `Fƒ±rsat No: ${opportunityNo} i√ßin bildirim (karma≈üƒ±k JSON string)`
          }
        };
        break;
        
      case 'wrong-format':
        // Yanlƒ±≈ü format testi - 'no' field'ƒ± string literal 'no' olarak geliyor
        testNotification = {
          data: {
            module: 'opportunity',
            fullDocument: wrongOpportunityData
          },
          notification: {
            title: 'Yeni Fƒ±rsat (Yanlƒ±≈ü Format)',
            body: `Fƒ±rsat i√ßin bildirim (no field'ƒ± yanlƒ±≈ü)`
          }
        };
        break;
    }

    await this.handleNotification(testNotification, isAppOpen);
  }

  /**
   * Android notification debug bilgilerini g√∂ster
   */
  async debugAndroidNotifications(): Promise<void> {
    if (Platform.OS !== 'android') {
      console.log('‚ö†Ô∏è Bu fonksiyon sadece Android i√ßin ge√ßerlidir');
      return;
    }

    console.log('ü§ñ Android Notification Debug Ba≈ülatƒ±lƒ±yor...');
    console.log('=====================================');
    
    // Firebase durumu
    console.log('üî• Firebase durumu:', {
      isInitialized: isFirebaseInitialized(),
      hasMessaging: !!this.messaging,
      hasRequestPermission: !!notificationFunctions.requestPermission,
      hasGetToken: !!notificationFunctions.getToken,
      hasOnMessage: !!notificationFunctions.onMessage
    });

    // ƒ∞zin durumu
    try {
      const permission = await this.requestPermissions();
      console.log('üì± ƒ∞zin durumu:', permission);
    } catch (error) {
      console.error('‚ùå ƒ∞zin kontrol√º hatasƒ±:', error);
    }

    // Token durumu
    try {
      const token = await this.getToken();
      console.log('üîë Token durumu:', {
        hasToken: !!token,
        tokenLength: token?.length || 0,
        tokenPreview: token ? token.substring(0, 30) + '...' : null
      });
    } catch (error) {
      console.error('‚ùå Token alma hatasƒ±:', error);
    }

    // Listener durumu
    console.log('üëÇ Listener durumu:', {
      hasMessageListener: !!this.messageListener,
      hasTokenRefreshListener: !!this.tokenRefreshListener
    });

    console.log('=====================================');
  }

  /**
   * Debug data kaydet
   */
  private async saveDebugData(remoteMessage: any, type: 'foreground' | 'background' | 'initial'): Promise<void> {
    try {
      const debugData: NotificationDebugData = {
        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        timestamp: new Date().toISOString(),
        type,
        platform: Platform.OS,
        rawData: remoteMessage,
        notification: remoteMessage.notification,
        data: remoteMessage.data,
        from: remoteMessage.from,
        messageId: remoteMessage.messageId,
        sentTime: remoteMessage.sentTime,
        ttl: remoteMessage.ttl,
      };

      // Data i√ßinden module ve fullDocument'ƒ± √ßƒ±kar
      if (remoteMessage.data) {
        debugData.module = remoteMessage.data.module;
        debugData.fullDocument = remoteMessage.data.fullDocument;
        
        // Parsed data'yƒ± da kaydet
        if (remoteMessage.data.fullDocument) {
          try {
            let parsedDocument = remoteMessage.data.fullDocument;
            
            // String ise parse etmeye √ßalƒ±≈ü
            if (typeof parsedDocument === 'string') {
              // √áoklu JSON parse (escape karakterleri i√ßin)
              let parseAttempts = 0;
              const maxAttempts = 5;
              
              while (typeof parsedDocument === 'string' && parseAttempts < maxAttempts) {
                try {
                  parsedDocument = JSON.parse(parsedDocument);
                  parseAttempts++;
                } catch {
                  break;
                }
              }
            }
            
            debugData.parsedData = parsedDocument;
          } catch (error) {
            console.error('‚ùå Debug data parse hatasƒ±:', error);
          }
        }
      }

      // Mevcut debug verilerini al
      const existingDataString = await AsyncStorage.getItem('notification_debug_data');
      let existingData: NotificationDebugData[] = [];
      
      if (existingDataString) {
        try {
          existingData = JSON.parse(existingDataString);
        } catch (error) {
          console.error('‚ùå Mevcut debug data parse hatasƒ±:', error);
          existingData = [];
        }
      }

      // Yeni veriyi ekle (en ba≈üa)
      existingData.unshift(debugData);

      // Maksimum 100 kayƒ±t tut (performans i√ßin)
      if (existingData.length > 100) {
        existingData = existingData.slice(0, 100);
      }

      // Kaydet
      await AsyncStorage.setItem('notification_debug_data', JSON.stringify(existingData));
      
      console.log('üíæ Debug data kaydedildi:', {
        id: debugData.id,
        type: debugData.type,
        module: debugData.module,
        hasFullDocument: !!debugData.fullDocument,
        totalRecords: existingData.length
      });
    } catch (error) {
      console.error('‚ùå Debug data kaydetme hatasƒ±:', error);
    }
  }

  /**
   * Debug verilerini temizle
   */
  async clearDebugData(): Promise<void> {
    try {
      await AsyncStorage.removeItem('notification_debug_data');
      console.log('‚úÖ Debug verileri temizlendi');
    } catch (error) {
      console.error('‚ùå Debug verileri temizleme hatasƒ±:', error);
    }
  }

  /**
   * Debug verilerini al
   */
  async getDebugData(): Promise<NotificationDebugData[]> {
    try {
      const dataString = await AsyncStorage.getItem('notification_debug_data');
      if (dataString) {
        return JSON.parse(dataString);
      }
      return [];
    } catch (error) {
      console.error('‚ùå Debug verileri alma hatasƒ±:', error);
      return [];
    }
  }

  /**
   * iOS Sim√ºlat√∂r FCM Token Debug
   */
  async debugIOSSimulatorFCMToken(): Promise<void> {
    if (Platform.OS !== 'ios') {
      console.log('‚ö†Ô∏è Bu debug fonksiyonu sadece iOS i√ßin ge√ßerlidir');
      return;
    }

    console.log('üçé iOS Sim√ºlat√∂r FCM Token Debug Ba≈ülatƒ±lƒ±yor...');
    console.log('=====================================');

    // 1. Platform ve ortam bilgileri
    console.log('üì± Platform Bilgileri:', {
      platform: Platform.OS,
      version: Platform.Version,
      isDev: __DEV__,
      isHermes: typeof HermesInternal !== 'undefined'
    });

    // 2. Firebase durumu
    console.log('üî• Firebase Durumu:', {
      isInitialized: isFirebaseInitialized(),
      hasMessaging: !!this.messaging,
      hasNotificationFunctions: !!notificationFunctions,
      availableFunctions: Object.keys(notificationFunctions)
    });

    // 3. Notification functions detaylarƒ±
    console.log('üîß Notification Functions Detaylarƒ±:', {
      getToken: !!notificationFunctions.getToken,
      requestPermission: !!notificationFunctions.requestPermission,
      onMessage: !!notificationFunctions.onMessage,
      onTokenRefresh: !!notificationFunctions.onTokenRefresh,
      AuthorizationStatus: !!notificationFunctions.AuthorizationStatus
    });

    // 4. Firebase mod√ºl y√ºkleme durumu
    try {
      const firebaseApp = await import('@react-native-firebase/app');
      const firebaseMessaging = await import('@react-native-firebase/messaging');
      console.log('‚úÖ Firebase mod√ºlleri ba≈üarƒ±yla import edildi');
      
      // Apps kontrol√º
      const apps = firebaseApp.getApps();
      console.log('üì± Firebase Apps:', {
        count: apps.length,
        names: apps.map(app => app.name)
      });

      // Messaging instance kontrol√º
      try {
        const messaging = firebaseMessaging.getMessaging();
        console.log('üì® Messaging Instance:', {
          exists: !!messaging,
          type: typeof messaging
        });
      } catch (msgError) {
        console.error('‚ùå Messaging Instance Hatasƒ±:', msgError);
      }

    } catch (importError) {
      console.error('‚ùå Firebase mod√ºl import hatasƒ±:', importError);
    }

    // 5. ƒ∞zin durumu kontrol
    try {
      console.log('üîç ƒ∞zin durumu kontrol ediliyor...');
      const permission = await this.requestPermissions();
      console.log('üìã ƒ∞zin Sonucu:', permission);
    } catch (permError) {
      console.error('‚ùå ƒ∞zin kontrol√º hatasƒ±:', permError);
    }

    // 6. Token alma denemesi
    try {
      console.log('üîë Token alma denemesi...');
      const token = await this.getToken();
      console.log('üîë Token Sonucu:', {
        hasToken: !!token,
        tokenLength: token?.length || 0,
        tokenPreview: token ? token.substring(0, 30) + '...' : null
      });
    } catch (tokenError) {
      console.error('‚ùå Token alma hatasƒ±:', tokenError);
    }

    // 7. APNs durumu (iOS √∂zel)
    try {
      console.log('üçé APNs durumu kontrol ediliyor...');
      
      // APNs token alma denemesi
      if (notificationFunctions.getAPNSToken) {
        try {
          const apnsToken = await notificationFunctions.getAPNSToken(this.messaging);
          console.log('üçé APNs Token:', apnsToken ? 'Mevcut' : 'Yok');
        } catch (apnsError) {
          console.log('üçé APNs Token Hatasƒ±:', apnsError instanceof Error ? apnsError.message : String(apnsError));
        }
      } else {
        console.log('üçé getAPNSToken fonksiyonu mevcut deƒüil');
      }

      // iOS authorization status
      if (notificationFunctions.requestPermission && notificationFunctions.AuthorizationStatus) {
        try {
          const authStatus = await notificationFunctions.requestPermission(this.messaging);
          console.log('üçé iOS Authorization Status:', {
            status: authStatus,
            AUTHORIZED: notificationFunctions.AuthorizationStatus.AUTHORIZED,
            DENIED: notificationFunctions.AuthorizationStatus.DENIED,
            NOT_DETERMINED: notificationFunctions.AuthorizationStatus.NOT_DETERMINED,
            PROVISIONAL: notificationFunctions.AuthorizationStatus.PROVISIONAL
          });
        } catch (authError) {
          console.log('üçé Authorization Status Hatasƒ±:', authError instanceof Error ? authError.message : String(authError));
        }
      }

    } catch (apnsError) {
      console.error('‚ùå APNs kontrol hatasƒ±:', apnsError);
    }

    console.log('=====================================');
    console.log('‚úÖ iOS Sim√ºlat√∂r FCM Token Debug Tamamlandƒ±');
    console.log('');
    console.log('üí° Olasƒ± √á√∂z√ºmler:');
    console.log('1. Fiziksel iOS cihazƒ±nda test edin');
    console.log('2. Firebase Console\'da APNs sertifikasƒ± kontrol edin');
    console.log('3. Xcode\'da Push Notifications capability\'si ekli mi kontrol edin');
    console.log('4. Bundle ID\'nin Firebase\'deki ile aynƒ± olduƒüunu kontrol edin');
    console.log('5. iOS Simulator Settings > Notifications > Your App > Allow Notifications');
  }

  /**
   * Notification logging durumunu g√∂ster
   */
  showNotificationLoggingInfo(): void {
    console.log('üìã Notification Logging Bilgileri:');
    console.log('‚úÖ Foreground mesajlar console\'da loglanƒ±yor');
    console.log('‚úÖ Background mesajlar console\'da loglanƒ±yor');
    console.log('‚úÖ Initial notification (uygulama bildirimle a√ßƒ±lƒ±rsa) loglanƒ±yor');
    console.log('‚úÖ Token refresh olaylarƒ± loglanƒ±yor');
    console.log('‚úÖ Local notification g√∂sterim olaylarƒ± loglanƒ±yor');
    console.log('‚úÖ Notification handler sistemi aktif');
    console.log('');
    console.log('üîç Loglanacak bildirim verileri:');
    console.log('  ‚Ä¢ title: Bildirim ba≈ülƒ±ƒüƒ±');
    console.log('  ‚Ä¢ body: Bildirim i√ßeriƒüi');
    console.log('  ‚Ä¢ data: √ñzel veri (custom payload)');
    console.log('  ‚Ä¢ from: G√∂nderen bilgisi');
    console.log('  ‚Ä¢ messageId: Mesaj ID\'si');
    console.log('  ‚Ä¢ sentTime: G√∂nderilme zamanƒ±');
    console.log('  ‚Ä¢ ttl: Time to live');
    console.log('  ‚Ä¢ timestamp: Log zamanƒ±');
    console.log('');
    console.log('üéØ Test i√ßin push notification g√∂nderin ve console\'ƒ± kontrol edin!');
    console.log('');
    console.log('‚öôÔ∏è Otomatik Y√∂nlendirme Ayarlarƒ±:');
    console.log('   NotificationService.getInstance().setAutoRedirect(true)  // Otomatik y√∂nlendir');
    console.log('   NotificationService.getInstance().setAutoRedirect(false) // Kullanƒ±cƒ±ya sor (varsayƒ±lan)');
    console.log('');
    console.log('üß™ Test Fonksiyonlarƒ±:');
    console.log('   Sale Test: NotificationService.getInstance().testNotificationHandler("12345", true/false)');
    console.log('   Opportunity Test: NotificationService.getInstance().testOpportunityNotificationHandler("67890", true/false)');
    console.log('   Bank Transaction Test: NotificationService.getInstance().testBankTransactionNotificationHandler("tx-12345", true/false)');
    console.log('');
    console.log('üì± Davranƒ±≈ü:');
    console.log('   - isAppOpen=true + autoRedirect=false: Kullanƒ±cƒ±ya onay sorar');
    console.log('   - isAppOpen=true + autoRedirect=true: Direkt y√∂nlendirir');
    console.log('   - isAppOpen=false: Her zaman direkt y√∂nlendirir');
  }
}

export default NotificationService;
